<!DOCTYPE html>
<html lang="ru">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>–†–µ–¥–∞–∫—Ç–æ—Ä –∫–∞—Ä—Ç –¥–ª—è —Ä–æ–±–æ—Ç–∞</title>
	<link rel="stylesheet" href="../editor/font-awesome_6-0-0.css">
	<style>
* {
	box-sizing: border-box;
	margin: 0;
	padding: 0;
}

body {
	font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
	background: #fff;
	color: #333;
	line-height: 1.6;
	min-height: 100vh;
	overflow-x: hidden;
}

.container {
	margin: 0 auto;
}

header {
	text-align: center;
	padding: 20px 0;
	margin-bottom: 20px;
}

h1 {
	font-size: 2.5rem;
	margin-bottom: 10px;
	color: #2c3e50;
}

.subtitle {
	font-size: 1.2rem;
	color: #666;
	max-width: 800px;
	margin: 0 auto;
}

.main-content {
}

@media (max-width: 900px) {
	.main-content {
		/*grid-template-columns: 1fr;*/
	}
}

.tools-panel {
	position: absolute;
	
	top: 15px;
	left: 15px;
	
	background: rlinear-gradient(135deg, #f5f7fa90, #e4e8ed90);
	border-radius: 7px;
	padding: 10px;
	box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
	border: 1px solid #e0e0e0;
	height: fit-content;
}

.panel-title {
	font-size: 1.4rem;
	margin-bottom: 20px;
	padding-bottom: 10px;
	border-bottom: 2px solid #4a9fe3;
	color: #2c3e50;
}

.tool-section {
	margin-bottom: 25px;
}

.tool-section h3 {
	font-size: 1.1rem;
	margin-bottom: 12px;
	color: #4a9fe3;
}


.tool-btn:hover {
	background: rgba(230, 235, 245, 0.9);
	transform: translateY(-2px);
	border-color: #bbb;
}

.tool-btn.active {
	background: #4a9fe3;
	color: white;
	border-color: #4a9fe3;
	box-shadow: 0 0 10px rgba(74, 159, 227, 0.3);
}

.input-group {
	margin-bottom: 15px;
}

.input-group label {
	display: block;
	margin-bottom: 5px;
	font-size: 0.95rem;
	color: #555;
}

.input-group input, .input-group select {
	padding: 10px;
	border-radius: 8px;
	border: 1px solid #ccc;
	background: #fff;
	color: #333;
	width: 100px;
}

.file-actions {
	display: flex;
	flex-direction: column;
	gap: 12px;
}

.action-btn {
	background: linear-gradient(to right, #4a9fe3, #3a7bc8);
	border: none;
	color: white;
	padding: 12px;
	border-radius: 8px;
	cursor: pointer;
	font-size: 1rem;
	transition: all 0.3s ease;
	text-align: center;
}

.action-btn:hover {
	transform: translateY(-3px);
	box-shadow: 0 5px 15px rgba(74, 159, 227, 0.3);
}

.action-btn.import {
	background: linear-gradient(to right, #27ae60, #219653);
}

.action-btn.export {
	background: linear-gradient(to right, #e67e22, #d35400);
}

.canvas-container {
	position: absolute;
	top: 0px;
	left: 0px;
	right: 0px;
	bottom: 0px;
	
	background: linear-gradient(135deg, #f5f7fa, #e4e8ed);
	overflow: auto;
	box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
	border: 1px solid #e0e0e0;
}

#gridCanvas {
	display: block;
	height: 100%;
	width: 100%;
	
	background: linear-gradient(135deg, #f5f7fa, #e4e8ed);
	cursor: default;
}

.status-bar {
	position: absolute;
	bottom: 10px;
	left: 10px;
	background: rgba(255, 255, 255, 0.9);
	padding: 8px 15px;
	border-radius: 20px;
	font-size: 0.9rem;
	color: #555;
	border: 1px solid #e0e0e0;
	box-shadow: 0 2px 5px rgba(0,0,0,0.05);
}

.legend {
	display: flex;
	flex-wrap: wrap;
	gap: 15px;
	margin-top: 20px;
	padding: 15px;
	background: rgba(255, 255, 255, 0.9);
	border-radius: 8px;
	border: 1px solid #e0e0e0;
}

.legend-item {
	display: flex;
	align-items: center;
	gap: 8px;
	font-size: 0.85rem;
	color: #555;
}

.legend-color {
	width: 20px;
	height: 20px;
	border-radius: 4px;
	border: 1px solid #ddd;
}

footer {
	text-align: center;
	margin-top: 30px;
	padding: 20px;
	font-size: 0.9rem;
	color: #666;
}

input {
	padding: 0 5px;
	width: 50px;
	border-radius: 8px;
	border: 1px solid #ccc;
	background: #fff;
	color: #333;
}


		.tool-buttons {
			display: flex;
			flex-direction: row;
			flex-wrap: wrap;
			gap: 8px;
			width: 100%;
			
			max-width: 100px;
		}

		.tool-btn {
			width: 44px;
			height: 44px;
			display: flex;
			align-items: center;
			justify-content: center;
			
			background: rgba(240, 240, 245, 0.9);
			border: 1px solid #ddd;
			color: #444;
			padding: 10px 15px;
			border-radius: 8px;
			cursor: pointer;
			transition: all 0.3s ease;
			flex-grow: 1;
			text-align: center;
			font-size: 0.9rem;
		}

		/* –°—Ç–∏–ª–∏ –¥–ª—è —Ç—É–ª—Ç–∏–ø–∞ */
		.tooltip {
			position: fixed;
			background: rgba(0, 0, 0, 0.85);
			color: white;
			padding: 6px 12px;
			border-radius: 4px;
			font-size: 0.85rem;
			z-index: 10000;
			pointer-events: none;
			transform: translate(10px, 10px);
			display: none;
			box-shadow: 0 2px 6px rgba(0,0,0,0.2);
		}

		.zoom-btn {
			position: absolute;
			right: 10px;
			bottom: 10px;
			
			width: 40px;
			height: 40px;
			border-radius: 50%;
			background: rgba(255, 255, 255, 0.9);
			border: none;
			color: #333333;
			font-size: 1.2rem;
			cursor: pointer;
			align-items: center;
			justify-content: center;
			box-shadow: 0 2px 5px rgba(0,0,0,0.05);
		}
	</style>
</head>
<body>
	<div class="container">
		<div class="main-content">
			<div class="canvas-container">
				<canvas id="gridCanvas"></canvas>
				<div class="status-bar">–¢–µ–∫—É—â–∏–π –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç: <span id="currentTool">–°—Ç–µ–Ω—ã</span> | –†–∞–∑–º–µ—Ä –∫–∞—Ä—Ç—ã: 
				<input type="text" id="map-size-x" value="0">√ó<input type="text" id="map-size-y" value="0"></div>
			</div>
			
			
			<div class="tools-panel">
				<div class="tool-section">
					<div class="tool-buttons">
						<button class="tool-btn active" data-tool="wall" data-tooltip="–°—Ç–µ–Ω—ã">üß±</button>
						<button class="tool-btn" data-tool="robot" data-tooltip="–†–æ–±–æ—Ç">üî∑</button>
						<button class="tool-btn" data-tool="point" data-tooltip="–¢–æ—á–∫–∞">‚Ä¢</button>
						<button class="tool-btn" data-tool="symbol1" data-tooltip="–°–∏–º–≤–æ–ª (–ø—Ä–∞–≤—ã–π)">&nbsp;&nbsp;üî°</button>
					</div>
				</div>
				
				<div class="tool-section">
					<div class="tool-buttons">
						<button class="tool-btn" data-tool="color" data-tooltip="–¶–≤–µ—Ç">üé®</button>
						<button class="tool-btn" data-tool="radiation" data-tooltip="–†–∞–¥–∏–∞—Ü–∏—è">‚ò¢Ô∏è</button>
						<button class="tool-btn" data-tool="temperature" data-tooltip="–¢–µ–º–ø–µ—Ä–∞—Ç—É—Ä–∞">üå°Ô∏è</button>
						<button class="tool-btn" data-tool="symbol" data-tooltip="–°–∏–º–≤–æ–ª (–ª–µ–≤—ã–π)">üî£&nbsp;&nbsp;</button>
					</div>
				</div>
				
				<div class="tool-section" id="tool-section-value" style="display: none;">
					<div class="input-group">
						<input type="text" id="tool-value" value="0">
					</div>
				</div>
				
				<div class="tool-section" id="tool-section-value-string" style="display: none;">
					<div class="input-group">
						<input type="text" id="tool-value-string" value="–ë">
					</div>
				</div>
				
				<div class="tool-section" style="margin-bottom: 0px;">
					<div class="tool-buttons">
						<button class="tool-btn action-btn import" id="importBtn" data-tooltip="–ò–º–ø–æ—Ä—Ç –∫–∞—Ä—Ç—ã">üì•</button>
						<button class="tool-btn action-btn export" id="exportBtn" data-tooltip="–≠–∫—Å–ø–æ—Ä—Ç –∫–∞—Ä—Ç—ã">üì§</button>
					</div>
				</div>
				
			</div>
			<button class="zoom-btn" id="resetZoomBtn"><i class="fas fa-expand-arrows-alt"></i></button>
		</div>
	</div>
	
	<script>
		// –û—Å–Ω–æ–≤–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ
		const canvas = document.getElementById('gridCanvas');
		const ctx = canvas.getContext('2d');
		const toolButtons = document.querySelectorAll('.tool-btn');
		const currentToolDisplay = document.getElementById('currentTool');
		//const mapSizeDisplay = document.getElementById('mapSize');
		
		// –°–æ—Å—Ç–æ—è–Ω–∏–µ —Ä–µ–¥–∞–∫—Ç–æ—Ä–∞
		const state = {
			gridWidth: 1,
			gridHeight: 1,
			cellSize: 80,
			scale: 1,
			offsetX: 10,
			offsetY: 10,
			isDragging: false,
			lastX: 0,
			lastY: 0,
			currentTool: 'wall',
			toolValue: 0,
			draggingRobot: false,
			toolCharValue: '–ë',
			robot: { x: 0, y: 0 },
			grid: []
		};
		
		// –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∫–∞—Ä—Ç—ã
		function initGrid() {
			state.grid = [];
			
			state.robot.x = 0;
			state.robot.y = 0;
			
			//mapSizeDisplay.textContent = `${state.gridWidth}√ó${state.gridHeight}`;
			
			document.getElementById('map-size-x').value = state.gridWidth;
			document.getElementById('map-size-y').value = state.gridHeight;
			
			drawGrid();
			
			state.scale = Math.min(
				canvas.width / ((state.gridWidth +2) * state.cellSize),
				canvas.height / ((state.gridHeight +2) * state.cellSize)
			);
		
			state.offsetX = (canvas.width - state.gridWidth * state.cellSize * state.scale) / 2;
			state.offsetY = (canvas.height - state.gridHeight * state.cellSize * state.scale) / 2;
			drawGrid();
			fil_test_export();
		}
		
		function clampOffsets() {
			const cellSizeScaled = state.cellSize * state.scale;
			const totalGridWidth = state.gridWidth * cellSizeScaled;
			const totalGridHeight = state.gridHeight * cellSizeScaled;
			// –û–ø—Ä–µ–¥–µ–ª—è–µ–º, –ø–æ–º–µ—â–∞–µ—Ç—Å—è –ª–∏ —Å–µ—Ç–∫–∞ –ø–æ —à–∏—Ä–∏–Ω–µ/–≤—ã—Å–æ—Ç–µ
			const fitsWidth = totalGridWidth <= canvas.width;
			const fitsHeight = totalGridHeight <= canvas.height;
			// –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º –≥—Ä–∞–Ω–∏—Ü—ã –¥–ª—è offsetX
			let minOffsetX, maxOffsetX;
			if (fitsWidth) {
				minOffsetX = 0; // –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –æ–¥–Ω—É –∫–ª–µ—Ç–∫—É —Å–ª–µ–≤–∞
				maxOffsetX = canvas.width - totalGridWidth; // –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –æ–¥–Ω—É –∫–ª–µ—Ç–∫—É —Å–ø—Ä–∞–≤–∞
			} else {
				minOffsetX = canvas.width - totalGridWidth - cellSizeScaled; // —Å–µ—Ç–∫–∞ –ø—Ä–∏–∂–∞—Ç–∞ –≤–ø—Ä–∞–≤–æ (–ø–æ–∫–∞–∑—ã–≤–∞–µ–º –ø—Ä–∞–≤—É—é —á–∞—Å—Ç—å —Å–µ—Ç–∫–∏)
				maxOffsetX = cellSizeScaled; // —Å–µ—Ç–∫–∞ –ø—Ä–∏–∂–∞—Ç–∞ –≤–ª–µ–≤–æ (–ø–æ–∫–∞–∑—ã–≤–∞–µ–º –ª–µ–≤—É—é —á–∞—Å—Ç—å —Å–µ—Ç–∫–∏)
			}
			// –î–ª—è offsetY –∞–Ω–∞–ª–æ–≥–∏—á–Ω–æ
			let minOffsetY, maxOffsetY;
			if (fitsHeight) {
				minOffsetY = 0;
				maxOffsetY = canvas.height - totalGridHeight; //+ cellSizeScaled;
			} else {
				minOffsetY = canvas.height - totalGridHeight -  cellSizeScaled;
				maxOffsetY =  cellSizeScaled;
			}
			// –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º
			state.offsetX = Math.max(minOffsetX, Math.min(maxOffsetX, state.offsetX));
			state.offsetY = Math.max(minOffsetY, Math.min(maxOffsetY, state.offsetY));
		}

		// –û—Ç—Ä–∏—Å–æ–≤–∫–∞ —Å–µ—Ç–∫–∏
		function drawGrid() {
			// –û—á–∏—Å—Ç–∫–∞ —Ö–æ–ª—Å—Ç–∞
			if (canvas.width != canvas.parentElement.clientWidth) canvas.width = canvas.parentElement.clientWidth;
			if (canvas.height != canvas.parentElement.clientHeight) canvas.height = canvas.parentElement.clientHeight;
			
			ctx.clearRect(0, 0, canvas.width, canvas.height);
			
			clampOffsets();
			
			
			
			// –ü—Ä–∏–º–µ–Ω–µ–Ω–∏–µ —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏–∏ –º–∞—Å—à—Ç–∞–±–∏—Ä–æ–≤–∞–Ω–∏—è –∏ —Å–º–µ—â–µ–Ω–∏—è
			ctx.save();
			ctx.translate(state.offsetX, state.offsetY);
			ctx.scale(state.scale, state.scale);
			
			// –û—Ç—Ä–∏—Å–æ–≤–∫–∞ —è—á–µ–µ–∫
			for (let y = 0; y < state.gridHeight; y++) {
				for (let x = 0; x < state.gridWidth; x++) {
					let d=false;
					for (const cell of state.grid) {
						if (cell.x == x && cell.y == y) {
							drawCell(cell);
							d = true;
						}
					}
					if (!d) {
						drawCell({x,y});
					}
				}
			}
			
			// –û—Ç—Ä–∏—Å–æ–≤–∫–∞ —Ä–æ–±–æ—Ç–∞
			drawRobot();
			
			ctx.restore();
		}
		
		// –û—Ç—Ä–∏—Å–æ–≤–∫–∞ —è—á–µ–π–∫–∏
		function drawCell(cell) {
			const x = cell.x * state.cellSize;
			const y = cell.y * state.cellSize;
			
			// –§–æ–Ω —è—á–µ–π–∫–∏
			ctx.fillStyle = cell.color ? 'rgba(39, 174, 96, 0.3)' : 'rgba(255, 255, 255, 0.05)';
			ctx.fillRect(x, y, state.cellSize, state.cellSize);
			
			// –ì—Ä–∞–Ω–∏—Ü—ã —è—á–µ–π–∫–∏
			ctx.strokeStyle = '#f1c40f';
			ctx.lineWidth = 1;
			ctx.strokeRect(x, y, state.cellSize, state.cellSize);
			
			// –°—Ç–µ–Ω—ã
			ctx.strokeStyle = '#f1c40f';
			ctx.lineWidth = 7;
			
			// –õ–µ–≤–∞—è —Å—Ç–µ–Ω–∞
			if (cell.wall & 1 || cell.x == 0) {
				ctx.beginPath();
				ctx.moveTo(x, y);
				ctx.lineTo(x, y + state.cellSize);
				ctx.stroke();
			}
			
			// –ü—Ä–∞–≤–∞—è —Å—Ç–µ–Ω–∞
			if (cell.wall & 2 || cell.x == state.gridWidth-1) {
				ctx.beginPath();
				ctx.moveTo(x + state.cellSize, y);
				ctx.lineTo(x + state.cellSize, y + state.cellSize);
				ctx.stroke();
			}
			
			// –í–µ—Ä—Ö–Ω—è—è —Å—Ç–µ–Ω–∞
			if (cell.wall & 8 || cell.y == 0) {
				ctx.beginPath();
				ctx.moveTo(x, y);
				ctx.lineTo(x + state.cellSize, y);
				ctx.stroke();
			}
			
			// –ù–∏–∂–Ω—è—è —Å—Ç–µ–Ω–∞
			if (cell.wall & 4 || cell.y == state.gridHeight-1) {
				ctx.beginPath();
				ctx.moveTo(x, y + state.cellSize);
				ctx.lineTo(x + state.cellSize, y + state.cellSize);
				ctx.stroke();
			}
			
			// –¢–µ–∫—Å—Ç: —Ä–∞–¥–∏–∞—Ü–∏—è (–Ω–∏–∂–Ω–∏–π –ª–µ–≤—ã–π —É–≥–æ–ª)
			if (cell.radiation && cell.radiation !== 0) {
				ctx.fillStyle = '#e74c3c';
				ctx.font = '12px Arial';
				ctx.fillText(cell.radiation.toFixed(2), x + 5, y + state.cellSize - 5);
			}
			
			// –¢–µ–∫—Å—Ç: —Ç–µ–º–ø–µ—Ä–∞—Ç—É—Ä–∞ (–Ω–∏–∂–Ω–∏–π –ø—Ä–∞–≤—ã–π —É–≥–æ–ª)
			if (cell.temperature && cell.temperature !== 0) {
				ctx.fillStyle = '#3498db';
				ctx.font = '12px Arial';
				ctx.fillText(cell.temperature.toFixed(2), x + state.cellSize - 35, y + state.cellSize - 5);
			}
			
			// –°–∏–º–≤–æ–ª—ã
			ctx.fillStyle = '#000';
			ctx.font = '16px Arial';
			
			// –õ–µ–≤—ã–π –≤–µ—Ä—Ö–Ω–∏–π —Å–∏–º–≤–æ–ª
			if (cell.symbol && cell.symbol !== '$') {
				ctx.fillText(cell.symbol, x + 8, y + 20);
			}
			
			// –ü—Ä–∞–≤—ã–π –≤–µ—Ä—Ö–Ω–∏–π —Å–∏–º–≤–æ–ª
			if (cell.symbol1 && cell.symbol1 !== '$') {
				ctx.fillText(cell.symbol1, x + state.cellSize - 20, y + 20);
			}
			
			// –¢–æ—á–∫–∞ (—Ä–æ–º–±)
			if (cell.point) {
				ctx.fillStyle = '#e74c3c';
				drawDiamond(ctx, x + state.cellSize/2 + 13, y + state.cellSize/2 - 26, 6);
			}
		}
		
		// –û—Ç—Ä–∏—Å–æ–≤–∫–∞ —Ä–æ–º–±–∞ (–¥–ª—è —Ç–æ—á–∫–∏ –∏ —Ä–æ–±–æ—Ç–∞)
		function drawDiamond(ctx, x, y, size) {
			ctx.beginPath();
			ctx.moveTo(x, y - size);
			ctx.lineTo(x + size, y);
			ctx.lineTo(x, y + size);
			ctx.lineTo(x - size, y);
			ctx.closePath();
			ctx.fill();
		}
		
		// –û—Ç—Ä–∏—Å–æ–≤–∫–∞ —Ä–æ–±–æ—Ç–∞
		function drawRobot() {
			const x = state.robot.x * state.cellSize + state.cellSize/2;
			const y = state.robot.y * state.cellSize + state.cellSize/2;
			
			ctx.fillStyle = '#4a9fe3';
			ctx.strokeStyle = '#ffffff';
			ctx.lineWidth = 2;
			
			drawDiamond(ctx, x, y, state.cellSize/3);
		}
		
		// –ü–æ–ª—É—á–µ–Ω–∏–µ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç —è—á–µ–π–∫–∏ –ø–æ –ø–æ–∑–∏—Ü–∏–∏ –º—ã—à–∏
		function getCellFromMouse(x, y) {
			// –ü—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç –º—ã—à–∏ —Å —É—á–µ—Ç–æ–º –º–∞—Å—à—Ç–∞–±–∞ –∏ —Å–º–µ—â–µ–Ω–∏—è
			const rect = canvas.getBoundingClientRect();
			const mouseX = (x - rect.left - state.offsetX) / state.scale;
			const mouseY = (y - rect.top - state.offsetY) / state.scale;
			
			const cellX = Math.floor(mouseX / state.cellSize);
			const cellY = Math.floor(mouseY / state.cellSize);
			
			const ncellX = mouseX / state.cellSize;
			const ncellY = mouseY / state.cellSize;
			
			if (cellX >= 0 && cellX < state.gridWidth && 
				cellY >= 0 && cellY < state.gridHeight) {
				return { x: cellX, y: cellY, nx: ncellX, ny: ncellY };
			}
			
			return null;
		}
		
		// –û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–ª–∏–∫–æ–≤
		function handleCellClick(cellX, cellY, wallSide) {
			let cell = state.grid.find(c => c.x === cellX && c.y === cellY);
			
			if (!cell) {
				state.grid.push({
						x: cellX, y: cellY,
						wall: 0,
						color: 0,
						radiation: 0,
						temperature: 0,
						symbol: '$',
						symbol1: '$',
						point: 0
					});
				
				cell = state.grid.find(c => c.x === cellX && c.y === cellY);
			}
			
			switch (state.currentTool) {
				case 'wall':
					if (cellX == 0 && wallSide == 'left') break;
					if (cellY == 0 && wallSide == 'top') break;
					if (cellX == state.gridWidth - 1 && wallSide == 'right') break;
					if (cellY == state.gridHeight - 1 && wallSide == 'bottom') break;
					
					// –û–ø—Ä–µ–¥–µ–ª—è–µ–º –±–∏—Ç –¥–ª—è –≤—ã–±—Ä–∞–Ω–Ω–æ–π —Å—Ç–æ—Ä–æ–Ω—ã —Å—Ç–µ–Ω—ã
					let wallBit;
					switch (wallSide) {
						case 'left': wallBit = 1; break;
						case 'right': wallBit = 2; break;
						case 'bottom': wallBit = 4; break;
						case 'top': wallBit = 8; break;
					}
					
					// –ü–µ—Ä–µ–∫–ª—é—á–∞–µ–º —Å—Ç–µ–Ω—É
					cell.wall ^= wallBit;
					break;
					
				case 'color':
					cell.color = cell.color ? 0 : 1;
					break;
					
				case 'radiation':
					cell.radiation = state.toolValue;
					break;
					
				case 'temperature':
					cell.temperature = state.toolValue;
					break;
					
				case 'symbol':
					cell.symbol = state.toolCharValue || '$';
					break;
					
				case 'symbol1':
					cell.symbol1 = state.toolCharValue || '$';
					break;
					
				case 'point':
					cell.point = cell.point ? 0 : 1;
					break;
					
				case 'robot':
					state.robot.x = cellX;
					state.robot.y = cellY;
					break;
			}
			
			drawGrid();
			fil_test_export();
		}
		
		function fil_test_export() {
			window.parent.postMessage({
						type: 'setFilValue',
						value: exportMapToString()
					}, '*');
		}
		
		// –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è
		function init() {
			
			// –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Å–µ—Ç–∫–∏
			initGrid();
			drawGrid();
			
			// –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ —Å–æ–±—ã—Ç–∏–π –º—ã—à–∏
			// –î–æ–±–∞–≤–ª—è–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏—è –¥–ª—è –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è –ø–æ—Å–ª–µ–¥–Ω–µ–π –æ–±—Ä–∞–±–æ—Ç–∞–Ω–Ω–æ–π —è—á–µ–π–∫–∏
			state.lastCell = null;
			state.lastWallSide = null;

			canvas.addEventListener('mousedown', (e) => {
				const cell = getCellFromMouse(e.clientX, e.clientY);
				
				if (e.button === 0) {
					if (state.currentTool === 'robot' && cell && 
						cell.x === state.robot.x && cell.y === state.robot.y) {
						state.draggingRobot = true;
					} else if (cell) {
						if (state.currentTool !== 'wall') {
							handleCellClick(cell.x, cell.y);
							state.lastCell = { x: cell.x, y: cell.y };
						} else {
							state.lastWallSide = computeWallSide(cell, e.clientX, e.clientY, true);
							if (state.lastWallSide == 'top' && cell.y>0) {
								cell.y--;
								state.lastWallSide = 'bottom'
							}
							if (state.lastWallSide == 'left' && cell.x>0) {
								cell.x--;
								state.lastWallSide = 'right';
							}
							state.lastCell = { x: cell.x, y: cell.y };
							if (state.lastWallSide) handleCellClick(cell.x, cell.y, state.lastWallSide);
							else {
								state.isDragging = true;
								state.lastX = e.clientX;
								state.lastY = e.clientY;
							}
						}
						state.drawing = true; // –§–ª–∞–≥ –Ω–∞—á–∞–ª–∞ —Ä–∏—Å–æ–≤–∞–Ω–∏—è
					} else {
						state.isDragging = true;
						state.lastX = e.clientX;
						state.lastY = e.clientY;
					}
				}
			});

			canvas.addEventListener('mousemove', (e) => {
				const cell = getCellFromMouse(e.clientX, e.clientY);
				
				if (state.isDragging) {
					// –ü–∞–Ω–æ—Ä–∞–º–∏—Ä–æ–≤–∞–Ω–∏–µ
					state.offsetX += e.clientX - state.lastX;
					state.offsetY += e.clientY - state.lastY;
					state.lastX = e.clientX;
					state.lastY = e.clientY;
					drawGrid();
				} else if (state.draggingRobot) {
					// –ü–µ—Ä–µ–º–µ—â–µ–Ω–∏–µ —Ä–æ–±–æ—Ç–∞
					if (cell && (state.robot.x != cell.x || state.robot.y != cell.y)) {
						state.robot.x = cell.x;
						state.robot.y = cell.y;
						drawGrid();
						fil_test_export();
					}
				} else if (state.drawing && cell) {
					// –û–±—Ä–∞–±–æ—Ç–∫–∞ —Ä–∏—Å–æ–≤–∞–Ω–∏—è –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–∞–º–∏
					if (state.currentTool !== 'wall') {
						// –î–ª—è –≤—Å–µ—Ö –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–æ–≤ –∫—Ä–æ–º–µ —Å—Ç–µ–Ω—ã
						if (!state.lastCell || cell.x !== state.lastCell.x || cell.y !== state.lastCell.y) {
							handleCellClick(cell.x, cell.y);
							state.lastCell = { x: cell.x, y: cell.y };
						}
					} else {
						// –°–ø–µ—Ü–∏–∞–ª—å–Ω–∞—è –ª–æ–≥–∏–∫–∞ –¥–ª—è —Å—Ç–µ–Ω—ã
						let currentSide = computeWallSide(cell, e.clientX, e.clientY);
						if (currentSide == 'top' && cell.y>0) {
							cell.y--;
							currentSide = 'bottom';
						}
						if (currentSide == 'left' && cell.x>0) {
							cell.x--;
							currentSide = 'right';
						}
						if (!currentSide) return;
						
						if (!state.lastCell || cell.x !== state.lastCell.x || cell.y !== state.lastCell.y || currentSide !== state.lastWallSide) {
							handleCellClick(cell.x, cell.y, currentSide);
							state.lastCell = { x: cell.x, y: cell.y };
							state.lastWallSide = currentSide;
						}
					}
				}
			});

			// –û–±—â–∏–µ –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ —Å–±—Ä–æ—Å–∞ —Å–æ—Å—Ç–æ—è–Ω–∏—è
			const resetState = () => {
				state.isDragging = false;
				state.draggingRobot = false;
				state.drawing = false;
				state.lastCell = null;
				state.lastWallSide = null;
			};

			canvas.addEventListener('mouseup', resetState);
			canvas.addEventListener('mouseleave', resetState);

			// –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è —Å—Ç–æ—Ä–æ–Ω—ã —Å—Ç–µ–Ω—ã
			function computeWallSide(cell, clientX, clientY, r) {
				const dx = cell.nx - (cell.x + 0.5);
				const dy = cell.ny - (cell.y + 0.5);
				let pos = {
					'right': [0.5, 0],
					'left': [-0.5, 0],
					'bottom': [0, 0.5],
					'top': [0, -0.5]
				}
				
				return Object.keys(pos).map(x=>{
					if (Math.abs(pos[x][0]-dx)+Math.abs(pos[x][1]-dy)<(r?0.4:0.3)) return x
				}).filter(x=>x)[0] || null;
			}
			
			// –ú–∞—Å—à—Ç–∞–±–∏—Ä–æ–≤–∞–Ω–∏–µ –∫–æ–ª–µ—Å–∏–∫–æ–º –º—ã—à–∏
			canvas.addEventListener('wheel', (e) => {	
				e.preventDefault();
				
				// –û–ø—Ä–µ–¥–µ–ª—è–µ–º –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∏ –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç –º–∞—Å—à—Ç–∞–±–∏—Ä–æ–≤–∞–Ω–∏—è
				const zoomIntensity = 0.1;
				const wheelDelta = -e.deltaY/200;
				const newScale = state.scale * (1 + wheelDelta * zoomIntensity);
				const clampedScale = Math.max(0.02, Math.min(10, newScale));
				
				// –ï—Å–ª–∏ –º–∞—Å—à—Ç–∞–± –Ω–µ –∏–∑–º–µ–Ω–∏–ª—Å—è - –≤—ã—Ö–æ–¥–∏–º
				if (clampedScale === state.scale) return;
				
				// –ö–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –∫—É—Ä—Å–æ—Ä–∞ –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω–æ —Ö–æ–ª—Å—Ç–∞
				const rect = canvas.getBoundingClientRect();
				const mouseX = e.clientX - rect.left;
				const mouseY = e.clientY - rect.top;
				
				// –†–∞–∑–Ω–∏—Ü–∞ –º–µ–∂–¥—É —Å—Ç–∞—Ä—ã–º –∏ –Ω–æ–≤—ã–º –º–∞—Å—à—Ç–∞–±–æ–º
				const scaleFactor = clampedScale / state.scale;
				
				// –ü–µ—Ä–µ—Å—á–∏—Ç—ã–≤–∞–µ–º —Å–º–µ—â–µ–Ω–∏–µ –¥–ª—è zoom –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω–æ –∫—É—Ä—Å–æ—Ä–∞
				state.offsetX = mouseX - scaleFactor * (mouseX - state.offsetX);
				state.offsetY = mouseY - scaleFactor * (mouseY - state.offsetY);
				
				// –û–±–Ω–æ–≤–ª—è–µ–º –º–∞—Å—à—Ç–∞–±
				state.scale = clampedScale;
				
				drawGrid();
			});
			
			// –í—ã–±–æ—Ä –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–∞
			toolButtons.forEach(btn => {
				btn.addEventListener('click', () => {
					toolButtons.forEach(b => b.classList.remove('active'));
					btn.classList.add('active');
					state.currentTool = btn.dataset.tool;
					document.getElementById('tool-section-value').style.display = ['temperature', 'radiation'].includes(state.currentTool)?'':'none';
					document.getElementById('tool-section-value-string').style.display = ['symbol', 'symbol1'].includes(state.currentTool)?'':'none';
					currentToolDisplay.textContent = btn.textContent;
					updateIframeHeight();
				});
			});
			
			document.getElementById('tool-value').addEventListener('input', (e) => {
				state.toolValue = parseFloat(e.target.value)||0;
			});
			document.getElementById('tool-value-string').addEventListener('input', (e) => {
				state.toolCharValue = e.target.value[0] || '$';
			});
			
			var is_first = true;
			
			document.getElementById('resetZoomBtn').addEventListener('click', ()=>{
				var elem = document.body;
				
				if (is_first) {
					is_first = false;
					if (elem.requestFullscreen) {
						elem.requestFullscreen();
					} else if (elem.mozRequestFullScreen) { /* Firefox */
						elem.mozRequestFullScreen();
					} else if (elem.webkitRequestFullscreen) { /* Chrome, Safari –∏ Opera */
						elem.webkitRequestFullscreen();
					} else if (elem.msRequestFullscreen) { /* IE/Edge */
						elem.msRequestFullscreen();
					}
				} else {
					is_first = true;
					if (document.exitFullscreen) {
						document.exitFullscreen();
					} else if (document.mozCancelFullScreen) { /* Firefox */
						document.mozCancelFullScreen();
					} else if (document.webkitExitFullscreen) { /* Chrome, Safari –∏ Opera */
						document.webkitExitFullscreen();
					} else if (document.msExitFullscreen) { /* IE/Edge */
						document.msExitFullscreen();
					}
				}
			});
			
			function update_size() {
				state.gridWidth = Math.max(parseFloat(document.getElementById('map-size-x').value) || 1,1);
				state.gridHeight = Math.max(parseFloat(document.getElementById('map-size-y').value) || 1,1);
				
				//mapSizeDisplay.textContent = `${state.gridWidth}√ó${state.gridHeight}`;
				drawGrid();
				fil_test_export();
			}
			
			document.getElementById('map-size-x').addEventListener('change', update_size);
			document.getElementById('map-size-y').addEventListener('change', update_size);
			// –ò–º–ø–æ—Ä—Ç/—ç–∫—Å–ø–æ—Ä—Ç
			document.getElementById('importBtn').addEventListener('click', importMap);
			document.getElementById('exportBtn').addEventListener('click', exportMap);
			
			

			// –û–±–Ω–æ–≤–ª—è–µ–º –≤—ã—Å–æ—Ç—É –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ —Å—Ç—Ä–∞–Ω–∏—Ü—ã
			updateIframeHeight();
			
			// –û–±–Ω–æ–≤–ª—è–µ–º –≤—ã—Å–æ—Ç—É –ø—Ä–∏ –∏–∑–º–µ–Ω–µ–Ω–∏–∏ —Å–æ–¥–µ—Ä–∂–∏–º–æ–≥–æ (–º–æ–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å –¥—Ä—É–≥–∏–µ —Å–æ–±—ã—Ç–∏—è –ø—Ä–∏ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç–∏)
			window.addEventListener('resize', updateIframeHeight);
			
			// –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–∞—Ö–æ–¥–∏–º—Å—è –ª–∏ –º—ã –≤–Ω—É—Ç—Ä–∏ iframe
			if (window.self !== window.top) {
				// –§—É–Ω–∫—Ü–∏—è –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –≤—ã—Å–æ—Ç—ã iframe
				
				
				window.addEventListener('message', function(event) {
					if (event.data.type && event.data.type === 'fil') {
						if (event.data.data=='') {
							initGrid()
						} else
							importMapFromString(event.data.data);
					}
				});
			}
		}
		
		function updateIframeHeight() {
			// –ü–æ–ª—É—á–∞–µ–º –≤—ã—Å–æ—Ç—É —Å–æ–¥–µ—Ä–∂–∏–º–æ–≥–æ –¥–æ–∫—É–º–µ–Ω—Ç–∞
			//const height = document.querySelector('.tools-panel').scrollHeight+40;
			
			// –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ —Ä–æ–¥–∏—Ç–µ–ª—å—Å–∫–æ–º—É –æ–∫–Ω—É —Å –Ω–æ–≤–æ–π –≤—ã—Å–æ—Ç–æ–π
			//window.parent.postMessage({
			//	type: 'setIframeFilHeight',
			//	height: height
			//}, '*'); // '*' –æ–∑–Ω–∞—á–∞–µ—Ç, —á—Ç–æ —Å–æ–æ–±—â–µ–Ω–∏–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ –≤ –ª—é–±–æ–π –¥–æ–º–µ–Ω
			
			//canvas.style.height = height-40 + 'px';
			canvas.width = canvas.parentElement.clientWidth;
			canvas.height = canvas.parentElement.clientHeight;
			drawGrid();
		}
		
		function importMapFromString(content) {
			try {
				const lines = content.split('\n').filter(line => !line.startsWith(';') && line.trim() !== '');
				
				// –†–∞–∑–º–µ—Ä –ø–æ–ª—è
				const size = lines[0].split(' ').map(Number);
				state.gridWidth = size[0];
				state.gridHeight = size[1];
				
				// –ü–æ–∑–∏—Ü–∏—è —Ä–æ–±–æ—Ç–∞
				const robotPos = lines[1].split(' ').map(Number);
				state.robot.x = robotPos[0];
				state.robot.y = robotPos[1];
				
				// –Ø—á–µ–π–∫–∏
				state.grid = [];
				for (let i = 2; i < lines.length; i++) {
					const parts = lines[i].split(' ');
					if (parts.length < 9) continue;
					
					state.grid.push({
						x: parseInt(parts[0]),
						y: parseInt(parts[1]),
						wall: parseInt(parts[2]),
						color: parseInt(parts[3]),
						radiation: parseFloat(parts[4]),
						temperature: parseFloat(parts[5]),
						symbol: parts[6].trim() === '' || parts[6] === '$' ? '$' : parts[6],
						symbol1: parts[7].trim() === '' || parts[7] === '$' ? '$' : parts[7],
						point: parseInt(parts[8])
					});
				}
				
				for (const cell of state.grid) {
					if (cell.wall & 8) {
						cell.wall ^= 8;
						const neighbor = state.grid.find(c => c.x === cell.x && c.y === cell.y - 1);
						if (neighbor) {
							neighbor.wall |= 4;
						} else {
							state.grid.push({
								x: cell.x,
								y: cell.y - 1,
								wall: 4,
								color: 0,
								radiation: 0,
								temperature: 0,
								symbol: '$',
								symbol1: '$',
								point: 0
							});
						}
					}
					if (cell.wall & 1) {
						cell.wall ^= 1;
						const neighbor = state.grid.find(c => c.x === cell.x - 1 && c.y === cell.y);
						if (neighbor) {
							neighbor.wall |= 2;
						} else {
							state.grid.push({
								x: cell.x - 1,
								y: cell.y,
								wall: 2,
								color: 0,
								radiation: 0,
								temperature: 0,
								symbol: '$',
								symbol1: '$',
								point: 0
							});
						}
					}
				}

				
				//mapSizeDisplay.textContent = `${state.gridWidth}√ó${state.gridHeight}`;
				document.getElementById('map-size-x').value = state.gridWidth;
				document.getElementById('map-size-y').value = state.gridHeight;
				
				
				drawGrid();
				state.scale = Math.min(
					canvas.width / ((state.gridWidth +2) * state.cellSize),
					canvas.height / ((state.gridHeight +2) * state.cellSize)
				);
				state.offsetX = (canvas.width - state.gridWidth * state.cellSize * state.scale) / 2;
				state.offsetY = (canvas.height - state.gridHeight * state.cellSize * state.scale) / 2;
				drawGrid();
				fil_test_export();
			} catch (error) {
				alert('–û—à–∏–±–∫–∞ –ø—Ä–∏ –∏–º–ø–æ—Ä—Ç–µ –∫–∞—Ä—Ç—ã: ' + error.message);
			}
		}
		
		// –ò–º–ø–æ—Ä—Ç –∫–∞—Ä—Ç—ã
		function importMap() {
			const input = document.createElement('input');
			input.type = 'file';
			input.accept = '.fil';
			
			input.onchange = e => {
				const file = e.target.files[0];
				if (!file) return;
				
				const reader = new FileReader();
				reader.onload = event => {
					try {
						const content = event.target.result;
						importMapFromString(content);
					} catch (error) {
						alert('–û—à–∏–±–∫–∞ –ø—Ä–∏ –∏–º–ø–æ—Ä—Ç–µ –∫–∞—Ä—Ç—ã2: ' + error.message);
					}
				};
				
				reader.readAsText(file);
			};
			
			input.click();
		}
		
		function exportMapToString() {
			let content = `; Field Size: x, y\n${state.gridWidth} ${state.gridHeight}\n`;
			content += `; Robot position: x, y\n${state.robot.x} ${state.robot.y}\n`;
			content += `; A set of special Fields: x, y, Wall, Color, Radiation, Temperature, Symbol, Symbol1, Point\n`;
			
			for (const cell of state.grid) {
				if (!(
					cell.wall == 0 &&
					cell.color == 0 &&
					cell.radiation == 0 &&
					cell.temperature == 0 &&
					cell.symbol == '$' &&
					cell.symbol1 == '$' &&
					cell.point == 0
				)&& cell.y<state.gridHeight && cell.x<state.gridWidth)
					content += `${cell.x} ${cell.y} ${cell.wall} ${cell.color} ${cell.radiation.toFixed(6)} ${cell.temperature.toFixed(6)} ${cell.symbol?cell.symbol[0]:'$'} ${cell.symbol1?cell.symbol1[0]:'$'} ${cell.point||''}\n`;
			}
			
			content += '; End Of File';
			return content;
		}
		
		// –≠–∫—Å–ø–æ—Ä—Ç –∫–∞—Ä—Ç—ã
		function exportMap() {
			
			
			const fileName = 'robot_map.fil';
			const blob = new Blob([exportMapToString()], { type: 'text/plain' });
			const url = URL.createObjectURL(blob);
			
			const a = document.createElement('a');
			a.href = url;
			a.download = fileName;
			document.body.appendChild(a);
			a.click();
			
			setTimeout(() => {
				document.body.removeChild(a);
				URL.revokeObjectURL(url);
			}, 100);
		}
		
		
		let currentTooltip = null;
		
		function createTooltip(element, text) {
			// –£–¥–∞–ª—è–µ–º –ø—Ä–µ–¥—ã–¥—É—â–∏–π —Ç—É–ª—Ç–∏–ø
			if (!currentTooltip) {
				const tooltip = document.createElement('div');
				tooltip.className = 'tooltip';
				document.body.appendChild(tooltip);
				currentTooltip = tooltip;
				//document.body.removeChild(currentTooltip);
			}
			
			// –°–æ–∑–¥–∞–µ–º –Ω–æ–≤—ã–π —Ç—É–ª—Ç–∏–ø
			
			// –ü–æ–∑–∏—Ü–∏–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ
			const updatePosition = (e) => {
				currentTooltip.style.left = (e.pageX + 15) + 'px';
				currentTooltip.style.top = (e.pageY + 15) + 'px';
			};
			
			// –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –ø—Ä–∏ –Ω–∞–≤–µ–¥–µ–Ω–∏–∏
			element.addEventListener('mouseenter', () => {
				currentTooltip.style.display = 'block';
				currentTooltip.textContent = text;
			});
			
			// –°–ª–µ–¥–∏–º –∑–∞ –¥–≤–∏–∂–µ–Ω–∏–µ–º –º—ã—à–∏
			element.addEventListener('mousemove', updatePosition);
			
			// –°–∫—Ä—ã–≤–∞–µ–º –ø—Ä–∏ —É—Ö–æ–¥–µ
			element.addEventListener('mouseleave', () => {
				currentTooltip.style.display = 'none';
			});
		}

		// –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Ç—É–ª—Ç–∏–ø–æ–≤ –¥–ª—è –≤—Å–µ—Ö —ç–ª–µ–º–µ–Ω—Ç–æ–≤ —Å data-tooltip
		document.querySelectorAll('[data-tooltip]').forEach(el => {
			createTooltip(el, el.dataset.tooltip);
		});
		
		// –ó–∞–ø—É—Å–∫ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è
		window.addEventListener('load', init);
	</script>
</body>
</html>