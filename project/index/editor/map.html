<!DOCTYPE html>
<html lang="ru">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Редактор карт</title>
	<link rel="stylesheet" href="../editor/font-awesome_6-0-0.css">
	<style>
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
}

body {
    background: #ffffff;
    color: #333333;
    min-height: 100vh;
    padding: 20px;
    overflow: hidden;
}

.container {
    display: flex;
    flex-direction: column;
    max-width: 1400px;
    margin: 0 auto;
    height: calc(100vh - 40px);
    gap: 15px;
}

header {
    text-align: center;
    padding: 15px;
    background: rgba(245, 245, 245, 0.9);
    border-radius: 12px;
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
    border: 1px solid rgba(0, 0, 0, 0.1);
}

h1 {
    font-size: 2.4rem;
    margin-bottom: 8px;
    color: #1976d2;
    text-shadow: none;
}

.subtitle {
    font-size: 1.1rem;
    opacity: 0.85;
    max-width: 800px;
    margin: 0 auto;
    color: #555555;
}

.main-content {
    height: calc(100% - 57px);
    display: flex;
    flex: 1;
    gap: 15px;
}

.toolbar {
    scrollbar-width: thin;
    scrollbar-color: #e0e0e0 #f5f5f5;
    overflow: auto;
    width: 200px;
    background: rgba(245, 245, 245, 0.9);
    border-radius: 12px;
    padding: 20px 15px;
    display: flex;
    flex-direction: column;
    gap: 15px;
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
    border: 1px solid rgba(0, 0, 0, 0.1);
}

.tool-section {
    margin-bottom: 15px;
}

.tool-section h3 {
    font-size: 1.1rem;
    margin-bottom: 12px;
    color: #1976d2;
    padding-bottom: 6px;
    border-bottom: 1px solid rgba(0, 0, 0, 0.1);
}

.tool-btn {
    display: flex;
    align-items: center;
    gap: 10px;
    width: 100%;
    padding: 10px 15px;
    margin-bottom: 8px;
    background: rgba(224, 224, 224, 0.6);
    border: none;
    border-radius: 8px;
    color: #333333;
    cursor: pointer;
    transition: all 0.2s ease;
    text-align: left;
    font-size: 0.95rem;
}

.tool-btn:hover {
    background: rgba(200, 200, 200, 0.7);
    transform: translateY(-2px);
}

.tool-btn.active {
    background: rgba(25, 118, 210, 0.2);
    box-shadow: 0 0 10px rgba(25, 118, 210, 0.2);
}

.tool-btn i {
    font-size: 1.2rem;
    width: 24px;
    text-align: center;
}

.properties-panel {
    position: absolute; 
    top: 10px;
    right: 10px;
    width: 280px;
    background: rgba(245, 245, 245, 0.9);
    border-radius: 12px;
    padding: 20px;
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
    border: 1px solid rgba(0, 0, 0, 0.1);
    overflow-y: auto;
}
#properties-panel {
    display: none;
}

.properties-panel h3 {
    font-size: 1.2rem;
    margin-bottom: 15px;
    color: #1976d2;
    text-align: center;
}

.property-group {
    background: rgba(224, 224, 224, 0.4);
    padding: 15px;
    border-radius: 8px;
}

.property-group h4 {
    font-size: 1rem;
    margin-bottom: 12px;
    color: #0d47a1;
}

.property-row {
    display: flex;
    justify-content: space-between;
    margin-bottom: 10px;
    align-items: center;
}

.property-label {
    font-size: 0.9rem;
    opacity: 0.9;
}

.property-input {
    width: 80px;
    padding: 6px 8px;
    background: rgba(255, 255, 255, 0.9);
    border: 1px solid rgba(0, 0, 0, 0.1);
    border-radius: 4px;
    color: #333333;
    text-align: center;
}

.editor-container {
    flex: 1;
    background: rgba(255, 255, 255, 0.9);
    border-radius: 12px;
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
    border: 1px solid rgba(0, 0, 0, 0.1);
    position: relative;
    overflow: hidden;
}

canvas {
    display: block;
    background: #f5f5f5;
}

.zoom-controls {
    position: absolute;
    right: 20px;
    bottom: 20px;
    display: flex;
    flex-direction: column;
    gap: 10px;
    z-index: 10;
}

.zoom-btn {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    background: rgba(224, 224, 224, 0.8);
    border: none;
    color: #333333;
    font-size: 1.2rem;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
    transition: all 0.2s ease;
}

.zoom-btn:hover {
    background: rgba(200, 200, 200, 0.9);
    transform: scale(1.1);
}

.status-bar {
    display: flex;
    justify-content: space-between;
    padding: 10px 20px;
    background: rgba(245, 245, 245, 0.9);
    border-radius: 12px;
    font-size: 0.9rem;
    box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
    border: 1px solid rgba(0, 0, 0, 0.1);
}

.legend {
    display: flex;
    gap: 20px;
}

.legend-item {
    display: flex;
    align-items: center;
    gap: 6px;
}

.legend-color {
    width: 15px;
    height: 15px;
    border-radius: 3px;
}

.dollar-legend { background: #ffd700; border-radius:50%; }
.road-h-legend { background: #8bc34a; height: 4px; }
.road-v-legend { background: #8bc34a; width: 4px; height: 15px; }
.room-legend { background: rgba(25, 118, 210, 0.2); }

.instructions {
    margin-top: 15px;
    padding: 10px;
    background: rgba(240, 240, 240, 0.9);
    border-radius: 8px;
    font-size: 0.9rem;
    color: #555555;
}
	</style>
</head>
<body>
	<div class="container">
		
		<div class="main-content">
			<div class="toolbar">
				<div class="tool-section">
					<h3><i class="fas fa-mouse-pointer"></i> Инструменты</h3>
					<button class="tool-btn active" id="select-tool">
						<i class="fas fa-vector-square"></i> Выделение
					</button>
					<button class="tool-btn" id="pan-tool">
						<i class="fas fa-eye"></i> Просмотр
					</button>
					<button class="tool-btn" id="delete-tool">
						<i class="fas fa-trash-alt"></i> Удаление
					</button>
				</div>
				
				<div class="tool-section">
					<h3><i class="fas fa-plus-circle"></i> Добавить элементы</h3>
					<button class="tool-btn" id="dollar-tool">
						<i class="fas fa-dollar-sign"></i> Доллар
					</button>
					<button class="tool-btn" id="rh-tool">
						<i class="fas fa-arrow-right-arrow-left"></i> Горизонтальная дорога
					</button>
					<button class="tool-btn" id="rv-tool">
						<i class="fas fa-arrow-right-arrow-left" style="transform: rotate(-90deg);"></i> Вертикальная дорога
					</button>
					<button class="tool-btn" id="room-tool">
						<i class="fas fa-border-all"></i> Комната
					</button>
				</div>
				
				<div class="tool-section">
					<h3><i class="fas fa-cog"></i> Настройки</h3>
					<button class="tool-btn" id="zoom-in">
						<i class="fas fa-search-plus"></i> Увеличить
					</button>
					<button class="tool-btn" id="zoom-out">
						<i class="fas fa-search-minus"></i> Уменьшить
					</button>
					<button class="tool-btn" id="reset-view">
						<i class="fas fa-sync-alt"></i> Сбросить вид
					</button>
				</div>
				
				<div class="tool-section">
					<h3><i class="fas fa-save"></i> Управление</h3>
					<button class="tool-btn" id="export-btn">
						<i class="fas fa-file-export"></i> Экспорт карты
					</button>
					<button class="tool-btn" id="import-btn">
						<i class="fas fa-file-import"></i> Импорт карты
					</button>
					<button class="tool-btn" id="clear-btn">
						<i class="fas fa-broom"></i> Очистить всё
					</button>
				</div>
			</div>
			
			<div class="editor-container">
				<canvas id="mapCanvas"></canvas>
				
				<div class="zoom-controls">
					<button class="zoom-btn" id="zoomInBtn"><i class="fas fa-plus"></i></button>
					<button class="zoom-btn" id="zoomOutBtn"><i class="fas fa-minus"></i></button>
					<button class="zoom-btn" id="resetZoomBtn"><i class="fas fa-expand-arrows-alt"></i></button>
				</div>
			</div>
			
			<div class="properties-panel" id="properties-panel">
				<h3><i class="fas fa-sliders-h"></i> Свойства элемента</h3>
				
				<div id="dollar-props" class="property-group" style="display: none;">
					<h4><i class="fas fa-dollar-sign"></i> Доллар</h4>
					<div class="property-row">
						<span class="property-label">X координата:</span>
						<input type="number" class="property-input" id="dollar-x" min="-10000" max="10000">
					</div>
					<div class="property-row">
						<span class="property-label">Y координата:</span>
						<input type="number" class="property-input" id="dollar-y" min="-10000" max="10000">
					</div>
					<div class="property-row">
						<span class="property-label">q:</span>
						<input type="number" class="property-input" id="dollar-probability" min="0" max="100">
					</div>
					<div class="property-row">
						<span class="property-label">b1:</span>
						<input type="number" class="property-input" id="dollar-init_probability" min="1" max="100">
					</div>
					Вероятность взять монетку n-ому подбирающему равна <var>b1 * q^(n-1)</var>
				</div>
				
				<div id="rh-props" class="property-group" style="display: none;">
					<h4><i class="fas fa-arrows-alt-h"></i> Горизонтальная дорога</h4>
					<div class="property-row">
						<span class="property-label">Начало X:</span>
						<input type="number" class="property-input" id="rh-x1" min="-100" max="100">
					</div>
					<div class="property-row">
						<span class="property-label">Конец X:</span>
						<input type="number" class="property-input" id="rh-x2" min="-100" max="100">
					</div>
					<div class="property-row">
						<span class="property-label">Y координата:</span>
						<input type="number" class="property-input" id="rh-y" min="-100" max="100">
					</div>
					<div class="property-row">
						<span class="property-label">Дверь:</span>
						<select id="rh-dor">
						</select>
					</div>
				</div>
				
				<div id="rv-props" class="property-group" style="display: none;">
					<h4><i class="fas fa-arrows-alt-v"></i> Вертикальная дорога</h4>
					<div class="property-row">
						<span class="property-label">X координата:</span>
						<input type="number" class="property-input" id="rv-x" min="-100" max="100">
					</div>
					<div class="property-row">
						<span class="property-label">Начало Y:</span>
						<input type="number" class="property-input" id="rv-y1" min="-100" max="100">
					</div>
					<div class="property-row">
						<span class="property-label">Конец Y:</span>
						<input type="number" class="property-input" id="rv-y2" min="-100" max="100">
					</div>
					<div class="property-row">
						<span class="property-label">Дверь:</span>
						<select id="rv-dor">
						</select>
					</div>
				</div>
				
				<div id="room-props" class="property-group" style="display: none;">
					<h4><i class="fas fa-border-style"></i> Комната</h4>
					<div class="property-row">
						<span class="property-label">X1:</span>
						<input type="number" class="property-input" id="room-x1" min="-100" max="100">
					</div>
					<div class="property-row">
						<span class="property-label">Y1:</span>
						<input type="number" class="property-input" id="room-y1" min="-100" max="100">
					</div>
					<div class="property-row">
						<span class="property-label">X2:</span>
						<input type="number" class="property-input" id="room-x2" min="-100" max="100">
					</div>
					<div class="property-row">
						<span class="property-label">Y2:</span>
						<input type="number" class="property-input" id="room-y2" min="-100" max="100">
					</div>
				</div>
				
			</div>
		</div>
		
		<div class="status-bar">
			<div class="coordinates">Координаты: (0, 0)</div>
			<div class="legend">
				<div class="legend-item">
					<div class="legend-color dollar-legend"></div>
					<span>Доллары</span>
				</div>
				<div class="legend-item">
					<div class="legend-color road-h-legend"></div>
					<span>Горизонтальные дороги</span>
				</div>
				<div class="legend-item">
					<div class="legend-color road-v-legend"></div>
					<span>Вертикальные дороги</span>
				</div>
				<div class="legend-item">
					<div class="legend-color room-legend"></div>
					<span>Комнаты</span>
				</div>
			</div>
			<div class="scale">Масштаб: 100%</div>
		</div>
	</div>

	<script>
		// Структура данных карты
		const mapData = {
			Ds: [{x: 1, y: 1}, {x: -2, y: 3}, {x: 4, y: -1}],
			RHs: [{x1: -3, x2: 3, y: 3}, {x1: -5, x2: -2, y: -2}],
			RVs: [{x: 3, y1: -3, y2: 3}, {x: -4, y1: 0, y2: 4}],
			ROOMs: [{x1: -1, y1: -1, x2: 1, y2: 1}, {x1: 2, y1: 0, x2: 5, y2: 3}]
		};

		// Состояние редактора
		const editorState = {
			tool: 'select', // select, pan, delete, dollar, rh, rv, room
			scale: 30.0,
			minScale: 1,
			maxScale: 300.0,
			offsetX: 0,
			offsetY: 0,
			isDragging: false,
			dragStartX: 0,
			dragStartY: 0,
			dragStartOffsetX: 0,
			dragStartOffsetY: 0,
			selectedElement: null,
			resizeHandle: null,
			tempElement: null,
			problems: []
		};

		// Элементы DOM
		const canvas = document.getElementById('mapCanvas');
		const ctx = canvas.getContext('2d');
		const coordDisplay = document.querySelector('.coordinates');
		const scaleDisplay = document.querySelector('.scale');
		
		// Настройка размера canvas
		function setupCanvas() {
			const container = canvas.parentElement;
			canvas.width = container.clientWidth;
			canvas.height = container.clientHeight;
		}
		
		// Преобразование координат
		function worldToScreen(x, y) {
			return {
				x: (x - editorState.offsetX) * editorState.scale + canvas.width/2,
				y: canvas.height/2 + (y - editorState.offsetY) * editorState.scale
			};
		}
		
		function screenToWorld(sx, sy) {
			return {
				x: editorState.offsetX + (sx - canvas.width/2) / editorState.scale,
				y: editorState.offsetY + (sy - canvas.height/2) / editorState.scale
			};
		}
		
		// Отрисовка сетки
		function drawGrid() {
			const gridSize = 1;
			const gridColor = 'rgba(100, 150, 255, 0.2)';
			const axisColor = '#4fc3f7';
			const textColor = '#1976d2';
			const gridStep = Math.max(1, Math.floor(10 / editorState.scale));
			
			ctx.strokeStyle = gridColor;
			ctx.lineWidth = 1;
			ctx.font = '10px Arial';
			ctx.fillStyle = textColor;
			ctx.textAlign = 'center';
			ctx.textBaseline = 'middle';
			
			const worldWidth = canvas.width / editorState.scale;
			const worldHeight = canvas.height / editorState.scale;
			
			const startX = Math.floor(screenToWorld(0,0).x/ gridStep)*gridStep;//Math.floor((editorState.offsetX - worldWidth/2) / gridStep) * gridStep;
			const endX = Math.ceil(screenToWorld(canvas.width,canvas.height).x/ gridStep)*gridStep;//Math.ceil((editorState.offsetX + worldWidth/2) / gridStep) * gridStep;
			
			const startY = Math.floor(screenToWorld(0,0).y/ gridStep)*gridStep;//Math.floor((editorState.offsetY - worldHeight/2) / gridStep) * gridStep;
			const endY = Math.ceil(screenToWorld(canvas.width,canvas.height).y/ gridStep)*gridStep;//Math.ceil((editorState.offsetY + worldHeight/2) / gridStep) * gridStep;
			
			// Вертикальные линии
			for (let x = startX; x <= endX; x += gridStep) {
				if (gridStep==1){
					const screenPos = worldToScreen(x-0.5, 0);
					ctx.beginPath();
					ctx.moveTo(screenPos.x, 0);
					ctx.lineTo(screenPos.x, canvas.height);
					ctx.stroke();
				}
				
				const screenPosText = worldToScreen(x, 0);
				// Подписи осей
				ctx.fillText(x, screenPosText.x, 10);
			}
			
			// Горизонтальные линии
			for (let y = startY; y <= endY; y += gridStep) {
				if (gridStep==1){
					const screenPos = worldToScreen(0, y+0.5);
					ctx.beginPath();
					ctx.moveTo(0, screenPos.y);
					ctx.lineTo(canvas.width, screenPos.y);
					ctx.stroke();
				}
				
				const screenPosText = worldToScreen(0, y);
				// Подписи осей
				ctx.fillText(y, 10, screenPosText.y);
			}
			
		}
		
		// Отрисовка элементов карты
		function drawMapElements() {
			const colors = {
				room_fill: 'rgba(100, 150, 255, 0.3)',
				room_stroke: 'rgba(100, 180, 255, 0.8)',
				road_fill: '#abe36a',
				road_stroke: '#8bc34a',
			}
			
			// Отрисовка комнат
			ctx.fillStyle = colors.room_fill;
			ctx.strokeStyle = colors.room_stroke;
			ctx.lineWidth = 5;
			
			[...mapData.ROOMs,...(editorState.tempElement&&editorState.tempElement.type=='room'?[editorState.tempElement]:[])].forEach(room => {
				const p1 = worldToScreen(room.x1-0.5, room.y1-0.5);
				const p2 = worldToScreen(room.x2+0.5, room.y2+0.5);
				
				const minX = Math.min(p1.x, p2.x);
				const maxX = Math.max(p1.x, p2.x);
				const minY = Math.min(p1.y, p2.y);
				const maxY = Math.max(p1.y, p2.y);
				
				ctx.fillRect(minX, minY, maxX - minX, maxY - minY);
				ctx.strokeRect(minX, minY, maxX - minX, maxY - minY);
			});
			
			// Отрисовка горизонтальных дорог
			ctx.fillStyle = colors.road_fill;
			ctx.strokeStyle = colors.road_stroke;
			ctx.font = Math.max(10, 0.5 * editorState.scale)+'px Arial';
			ctx.textAlign = 'center';
			ctx.textBaseline = 'middle';
			//ctx.lineWidth = 2;
			
			// GetExcelColumnName(x)
			// Отрисовка горизонтальных дорог
			[...mapData.RHs,...(editorState.tempElement&&editorState.tempElement.type=='rh'?[editorState.tempElement]:[])].forEach(road => {
				const p1 = worldToScreen(road.x1-0.5, road.y-0.5);
				const p2 = worldToScreen(road.x2+0.5, road.y+0.5);
				
				const minX = Math.min(p1.x, p2.x);
				const maxX = Math.max(p1.x, p2.x);
				const minY = Math.min(p1.y, p2.y);
				const maxY = Math.max(p1.y, p2.y);
				
				ctx.fillRect(minX, minY, maxX - minX, maxY - minY);
				
				ctx.strokeStyle = colors.road_stroke;
				ctx.beginPath();
				ctx.moveTo(minX, minY);
				ctx.lineTo(maxX, minY);
				ctx.moveTo(minX, maxY);
				ctx.lineTo(maxX, maxY);
				ctx.stroke();
				
				ctx.strokeStyle = colors.room_stroke;
				ctx.beginPath();
				ctx.moveTo(minX, minY);
				ctx.lineTo(minX, maxY);
				ctx.moveTo(maxX, minY);
				ctx.lineTo(maxX, maxY);
				ctx.stroke();
				
				// Добавляем отображение буквенного индекса
				if (road.dor && road.dor.startsWith('task:')) {
					const index = select_data.findIndex(item => item.value === road.dor);
					
					const centerX = (minX + maxX) / 2;
					const centerY = (minY + maxY) / 2;
					
					if (index-1>0) {
						const columnName = GetExcelColumnName(index-1);
						
						ctx.fillStyle = '#000'; // черный цвет текста
						ctx.fillText(columnName, centerX, centerY);
						ctx.fillStyle = colors.road_fill;
					} else {
						ctx.fillStyle = '#F00';
						ctx.fillText('!!!', centerX, centerY);
						ctx.fillStyle = colors.road_fill;
						
					}
				}
			});

			// Отрисовка вертикальных дорог
			[...mapData.RVs,...(editorState.tempElement&&editorState.tempElement.type=='rv'?[editorState.tempElement]:[])].forEach(road => {
				const p1 = worldToScreen(road.x-0.5, road.y1-0.5);
				const p2 = worldToScreen(road.x+0.5, road.y2+0.5);
				
				const minX = Math.min(p1.x, p2.x);
				const maxX = Math.max(p1.x, p2.x);
				const minY = Math.min(p1.y, p2.y);
				const maxY = Math.max(p1.y, p2.y);
				
				ctx.fillRect(minX, minY, maxX - minX, maxY - minY);
				
				ctx.strokeStyle = colors.road_stroke;
				ctx.beginPath();
				ctx.moveTo(minX, minY);
				ctx.lineTo(minX, maxY);
				ctx.moveTo(maxX, minY);
				ctx.lineTo(maxX, maxY);
				ctx.stroke();
				
				ctx.strokeStyle = colors.room_stroke;
				ctx.beginPath();
				ctx.moveTo(minX, minY);
				ctx.lineTo(maxX, minY);
				ctx.moveTo(minX, maxY);
				ctx.lineTo(maxX, maxY);
				ctx.stroke();
				
				// Добавляем отображение буквенного индекса
				if (road.dor && road.dor.startsWith('task:')) {
					const index = select_data.findIndex(item => item.value === road.dor);
					
					const centerX = (minX + maxX) / 2;
					const centerY = (minY + maxY) / 2;
					
					if (index-1>0) {
						const columnName = GetExcelColumnName(index-1);
						
						ctx.fillStyle = '#000'; // черный цвет текста
						ctx.fillText(columnName, centerX, centerY);
						ctx.fillStyle = colors.road_fill;
					} else {
						ctx.fillStyle = '#F00';
						ctx.fillText('!!!', centerX, centerY);
						ctx.fillStyle = colors.road_fill;
						
					}
				}
			});
			
			
			ctx.fillStyle = '#00ff00ff';
			ctx.fillRect(worldToScreen(-0.5, -0.5).x,worldToScreen(-0.5, -0.5).y,editorState.scale,editorState.scale);
			
			// Отрисовка долларов
			ctx.fillStyle = '#ffd700';
			ctx.strokeStyle = '#b8860b';
			ctx.lineWidth = 1;
			
			mapData.Ds.forEach(dollar => {
				const pos = worldToScreen(dollar.x, dollar.y);
				const radius = 0.5 * editorState.scale;
				
				ctx.beginPath();
				ctx.arc(pos.x, pos.y, radius, 0, Math.PI * 2);
				ctx.fill();
				ctx.stroke();
				
				// Знак доллара
				ctx.fillStyle = '#000';
				ctx.font = `${Math.max(10, 0.5 * editorState.scale)}px Arial`;
				ctx.textAlign = 'center';
				ctx.textBaseline = 'middle';
				ctx.fillText('$', pos.x, pos.y);
				ctx.fillStyle = '#ffd700';
			});
			
			
			ctx.fillStyle = '#ffd700';
			ctx.strokeStyle = '#b8860b';
			ctx.lineWidth = 5;
			
			 if ((new Date()%1000)>500)
			editorState.problems.forEach(problem => {
				const p1 = worldToScreen(problem.x-0.5, problem.y-0.5);
				const p2 = worldToScreen(problem.x+0.5, problem.y+0.5);
				
				const minX = Math.min(p1.x, p2.x);
				const maxX = Math.max(p1.x, p2.x);
				const minY = Math.min(p1.y, p2.y);
				const maxY = Math.max(p1.y, p2.y);
				
				ctx.fillRect(minX, minY, maxX - minX, maxY - minY);
				ctx.strokeRect(minX, minY, maxX - minX, maxY - minY);
				
				const centerX = (minX + maxX) / 2;
				const centerY = (minY + maxY) / 2;
				
				// Знак доллара
				ctx.fillStyle = '#000';
				ctx.font = `${Math.max(10, 0.5 * editorState.scale)}px Arial`;
				ctx.textAlign = 'center';
				ctx.textBaseline = 'middle';
				ctx.fillText('!', centerX, centerY);
				ctx.fillStyle = '#ffd700';
			});
		}
		
		// Отрисовка выделения
		function drawSelection() {
			if (!editorState.selectedElement) return;
			
			const element = editorState.selectedElement;
			ctx.strokeStyle = '#ffeb3b';
			ctx.lineWidth = 2;
			ctx.setLineDash([5, 3]);
			
			if (element.type === 'dollar') {
				const pos = worldToScreen(element.data.x, element.data.y);
				const radius = 0.5 * 1.1 * editorState.scale;
				
				ctx.beginPath();
				ctx.arc(pos.x, pos.y, radius, 0, Math.PI * 2);
				ctx.stroke();
			} 
			else if (element.type === 'rh') {
				const start = worldToScreen(element.data.x1, element.data.y);
				const end = worldToScreen(element.data.x2, element.data.y);
				
				ctx.beginPath();
				ctx.moveTo(start.x, start.y);
				ctx.lineTo(end.x, end.y);
				ctx.stroke();
				
				// Маркеры изменения размера
				drawResizeHandle(start.x, start.y);
				drawResizeHandle(end.x, end.y);
			} 
			else if (element.type === 'rv') {
				const start = worldToScreen(element.data.x, element.data.y1);
				const end = worldToScreen(element.data.x, element.data.y2);
				
				ctx.beginPath();
				ctx.moveTo(start.x, start.y);
				ctx.lineTo(end.x, end.y);
				ctx.stroke();
				
				// Маркеры изменения размера
				drawResizeHandle(start.x, start.y);
				drawResizeHandle(end.x, end.y);
			} 
			else if (element.type === 'room') {
				const p1 = worldToScreen(element.data.x1, element.data.y1);
				const p2 = worldToScreen(element.data.x2, element.data.y2);
				
				const minX = Math.min(p1.x, p2.x);
				const maxX = Math.max(p1.x, p2.x);
				const minY = Math.min(p1.y, p2.y);
				const maxY = Math.max(p1.y, p2.y);
				
				ctx.strokeRect(minX, minY, maxX - minX, maxY - minY);
				
				// Маркеры изменения размера
				drawResizeHandle(minX, minY);
				drawResizeHandle(minX, maxY);
				drawResizeHandle(maxX, minY);
				drawResizeHandle(maxX, maxY);
			}
			
			ctx.setLineDash([]);
		}
		
		// Отрисовка маркера изменения размера
		function drawResizeHandle(x, y) {
			ctx.fillStyle = '#ffeb3b';
			ctx.strokeStyle = '#000';
			ctx.lineWidth = 1;
			
			const size = 8;
			ctx.fillRect(x - size/2, y - size/2, size, size);
			ctx.strokeRect(x - size/2, y - size/2, size, size);
		}
		
		// Проверка попадания в элемент
		function hitTest(x, y) {
			// Проверка долларов
			for (let i = 0; i < mapData.Ds.length; i++) {
				const dollar = mapData.Ds[i];
				const pos = worldToScreen(dollar.x, dollar.y);
				const distance = Math.sqrt(Math.pow(pos.x - x, 2) + Math.pow(pos.y - y, 2));
				const radius = 0.5 * 1 * editorState.scale;
				
				if (distance < radius) {
					return { type: 'dollar', index: i, data: dollar };
				}
			}
			
			// Проверка горизонтальных дорог
			for (let i = 0; i < mapData.RHs.length; i++) {
				const road = mapData.RHs[i];
				const p1 = worldToScreen(road.x1-0.5, road.y-0.5);
				const p2 = worldToScreen(road.x2+0.5, road.y+0.5);
				
				const minX = Math.min(p1.x, p2.x);
				const maxX = Math.max(p1.x, p2.x);
				const minY = Math.min(p1.y, p2.y);
				const maxY = Math.max(p1.y, p2.y);
				
				if (x >= minX && x <= maxX && y >= minY && y <= maxY) {
					return { type: 'rh', index: i, data: road };
				}
			}
			
			// Проверка вертикальных дорог
			for (let i = 0; i < mapData.RVs.length; i++) {
				const road = mapData.RVs[i];
				const p1 = worldToScreen(road.x-0.5, road.y1-0.5);
				const p2 = worldToScreen(road.x+0.5, road.y2+0.5);
				
				const minX = Math.min(p1.x, p2.x);
				const maxX = Math.max(p1.x, p2.x);
				const minY = Math.min(p1.y, p2.y);
				const maxY = Math.max(p1.y, p2.y);
				
				if (x >= minX && x <= maxX && y >= minY && y <= maxY) {
					return { type: 'rv', index: i, data: road };
				}
			}
			
			// Проверка комнат
			for (let i = 0; i < mapData.ROOMs.length; i++) {
				const room = mapData.ROOMs[i];
				const p1 = worldToScreen(room.x1-0.5, room.y1-0.5);
				const p2 = worldToScreen(room.x2+0.5, room.y2+0.5);
				
				const minX = Math.min(p1.x, p2.x);
				const maxX = Math.max(p1.x, p2.x);
				const minY = Math.min(p1.y, p2.y);
				const maxY = Math.max(p1.y, p2.y);
				
				if (x >= minX && x <= maxX && y >= minY && y <= maxY) {
					return { type: 'room', index: i, data: room };
				}
			}
			
			return null;
		}
		
		// Проверка попадания в маркер изменения размера
		function hitTestResizeHandle(x, y) {
			if (!editorState.selectedElement) return null;
			
			const element = editorState.selectedElement;
			const size = 10;
			
			if (element.type === 'dollar') {
				return null;
			} 
			else if (element.type === 'rh') {
				const start = worldToScreen(element.data.x1, element.data.y);
				const end = worldToScreen(element.data.x2, element.data.y);
				
				if (Math.abs(start.x - x) < size && Math.abs(start.y - y) < size) {
					return 'start';
				}
				if (Math.abs(end.x - x) < size && Math.abs(end.y - y) < size) {
					return 'end';
				}
			} 
			else if (element.type === 'rv') {
				const start = worldToScreen(element.data.x, element.data.y1);
				const end = worldToScreen(element.data.x, element.data.y2);
				
				if (Math.abs(start.x - x) < size && Math.abs(start.y - y) < size) {
					return 'start';
				}
				if (Math.abs(end.x - x) < size && Math.abs(end.y - y) < size) {
					return 'end';
				}
			} 
			else if (element.type === 'room') {
				const p1 = worldToScreen(element.data.x1, element.data.y1);
				const p2 = worldToScreen(element.data.x2, element.data.y2);
				
				const minX = Math.min(p1.x, p2.x);
				const maxX = Math.max(p1.x, p2.x);
				const minY = Math.min(p1.y, p2.y);
				const maxY = Math.max(p1.y, p2.y);
				
				if (Math.abs(minX - x) < size && Math.abs(minY - y) < size) return 'nw';
				if (Math.abs(minX - x) < size && Math.abs(maxY - y) < size) return 'sw';
				if (Math.abs(maxX - x) < size && Math.abs(minY - y) < size) return 'ne';
				if (Math.abs(maxX - x) < size && Math.abs(maxY - y) < size) return 'se';
			}
			
			return null;
		}
		
		
		// Обновление свойств элемента в UI
		function updatePropertiesPanel() {
			// Скрываем все группы свойств
			
			document.getElementById('properties-panel').style.display = 'none';
			document.querySelectorAll('.property-group').forEach(el => {
				el.style.display = 'none';
			});
			
			if (!editorState.selectedElement) return;
			
			const element = editorState.selectedElement;
			
			const selectElement = document.getElementById('rh-dor');
			['rh-dor', 'rv-dor'].map(x=>{
				document.getElementById(x).innerHTML = '';
				
				select_data.forEach(item => {
					const option = document.createElement('option');
					option.textContent = item.text;
					option.value = item.value;
					document.getElementById(x).appendChild(option);
				});
			});
			
			document.getElementById('properties-panel').style.display = 'block';
			if (element.type === 'dollar') {
				document.getElementById('dollar-props').style.display = 'block';
				document.getElementById('dollar-x').value = element.data.x;
				document.getElementById('dollar-y').value = element.data.y;
				document.getElementById('dollar-probability').value = (element.data.probability || 0) * 100;
				document.getElementById('dollar-init_probability').value = (element.data.init_probability || 1) * 100;
			} 
			else if (element.type === 'rh') {
				document.getElementById('rh-props').style.display = 'block';
				document.getElementById('rh-x1').value = element.data.x1;
				document.getElementById('rh-x2').value = element.data.x2;
				document.getElementById('rh-y').value = element.data.y;
				document.getElementById('rh-dor').value = element.data.dor || "";
			} 
			else if (element.type === 'rv') {
				document.getElementById('rv-props').style.display = 'block';
				document.getElementById('rv-x').value = element.data.x;
				document.getElementById('rv-y1').value = element.data.y1;
				document.getElementById('rv-y2').value = element.data.y2;
				document.getElementById('rv-dor').value = element.data.dor || "";
			} 
			else if (element.type === 'room') {
				document.getElementById('room-props').style.display = 'block';
				document.getElementById('room-x1').value = element.data.x1;
				document.getElementById('room-y1').value = element.data.y1;
				document.getElementById('room-x2').value = element.data.x2;
				document.getElementById('room-y2').value = element.data.y2;
			}
		}
		
		// Основная функция отрисовки
		function draw() {
			setupCanvas();
			
			ctx.clearRect(0, 0, canvas.width, canvas.height);
			drawGrid();
			drawMapElements();
			drawSelection();
			
			requestAnimationFrame(draw);
		}
		
		// Инициализация редактора
		function initEditor() {
			setupCanvas();
			draw();
			
			// Обработчики свойств элементов
			let tupdateElementProperties = (e) => {console.log(editorState.selectedElement); setTimeout(updateElementProperties, 10);};
			['keydown', 'change'].map((x)=>{
				document.getElementById('dollar-x').addEventListener(x, tupdateElementProperties);
				document.getElementById('dollar-y').addEventListener(x, tupdateElementProperties);
				document.getElementById('dollar-probability').addEventListener(x, tupdateElementProperties);
				document.getElementById('dollar-init_probability').addEventListener(x, tupdateElementProperties);
				document.getElementById('rh-x1').addEventListener(x, tupdateElementProperties);
				document.getElementById('rh-x2').addEventListener(x, tupdateElementProperties);
				document.getElementById('rh-y').addEventListener(x, tupdateElementProperties);
				document.getElementById('rh-dor').addEventListener(x, tupdateElementProperties);
				document.getElementById('rv-x').addEventListener(x, tupdateElementProperties);
				document.getElementById('rv-y1').addEventListener(x, tupdateElementProperties);
				document.getElementById('rv-y2').addEventListener(x, tupdateElementProperties);
				document.getElementById('rv-dor').addEventListener(x, tupdateElementProperties);
				document.getElementById('room-x1').addEventListener(x, tupdateElementProperties);
				document.getElementById('room-y1').addEventListener(x, tupdateElementProperties);
				document.getElementById('room-x2').addEventListener(x, tupdateElementProperties);
				document.getElementById('room-y2').addEventListener(x, tupdateElementProperties);
			});
			// Обработчики событий мыши
			canvas.addEventListener('mousedown', handleMouseDown);
			canvas.addEventListener('mousemove', handleMouseMove);
			canvas.addEventListener('mouseup', handleMouseUp);
			canvas.addEventListener('mouseout', handleMouseUp);
			canvas.addEventListener('wheel', handleMouseWheel);
			
			// Обработчики кнопок инструментов
			document.getElementById('select-tool').addEventListener('click', () => setTool('select'));
			document.getElementById('pan-tool').addEventListener('click', () => setTool('pan'));
			document.getElementById('delete-tool').addEventListener('click', () => setTool('delete'));
			document.getElementById('dollar-tool').addEventListener('click', () => setTool('dollar'));
			document.getElementById('rh-tool').addEventListener('click', () => setTool('rh'));
			document.getElementById('rv-tool').addEventListener('click', () => setTool('rv'));
			document.getElementById('room-tool').addEventListener('click', () => setTool('room'));
			
			// Обработчики кнопок масштабирования
			document.getElementById('zoomInBtn').addEventListener('click', () => zoom(1.2));
			document.getElementById('zoomOutBtn').addEventListener('click', () => zoom(0.8));
			document.getElementById('resetZoomBtn').addEventListener('click', ()=>{ editorPostMessage('Full'); });
			document.getElementById('zoom-in').addEventListener('click', () => zoom(1.2));
			document.getElementById('zoom-out').addEventListener('click', () => zoom(0.8));
			document.getElementById('reset-view').addEventListener('click', resetView);
			
			// Обработчики кнопок управления
			document.getElementById('export-btn').addEventListener('click', exportMap);
			document.getElementById('import-btn').addEventListener('click', importMap);
			document.getElementById('clear-btn').addEventListener('click', clearMap);
			
			// Обработчик клавиатуры
			document.addEventListener('keydown', handleKeyDown);
			
		}
		
		// Установка активного инструмента
		function setTool(tool) {
			editorState.tool = tool;
			
			// Обновление UI
			document.querySelectorAll('.tool-btn').forEach(btn => {
				btn.classList.remove('active');
			});
			
			if (tool === 'select') document.getElementById('select-tool').classList.add('active');
			if (tool === 'pan') document.getElementById('pan-tool').classList.add('active');
			if (tool === 'delete') document.getElementById('delete-tool').classList.add('active');
			if (tool === 'dollar') document.getElementById('dollar-tool').classList.add('active');
			if (tool === 'rh') document.getElementById('rh-tool').classList.add('active');
			if (tool === 'rv') document.getElementById('rv-tool').classList.add('active');
			if (tool === 'room') document.getElementById('room-tool').classList.add('active');
			
			editorState.selectedElement = null;
			editorState.tempElement = null;
		}
		
		// Обработка событий мыши
		function handleMouseDown(e) {
			//updateElementProperties();
			const rect = canvas.getBoundingClientRect();
			const x = e.clientX - rect.left;
			const y = e.clientY - rect.top;
			const worldPos = screenToWorld(x, y);
			
			editorState.isDragging = true;
			editorState.dragStartX = x;
			editorState.dragStartY = y;
			editorState.dragStartOffsetX = editorState.offsetX;
			editorState.dragStartOffsetY = editorState.offsetY;
			
			if (editorState.tool === 'pan') {
				return;
			}
			
			const element = hitTest(x, y);
			
			if (editorState.tool === 'delete') {
				if (element) {
					deleteElement(element);
				}
				return;
			}
			
			if (editorState.tool === 'dollar') {
				setTool('select');
				mapData.Ds.push({x: worldPos.x, y: worldPos.y});
				editorState.selectedElement = { 
					type: 'dollar', 
					index: mapData.Ds.length - 1, 
					data: mapData.Ds[mapData.Ds.length - 1] 
				};
				updatePropertiesPanel();
			}
			else if (element) {
				editorState.selectedElement = element;
				editorState.resizeHandle = hitTestResizeHandle(x, y);
				updatePropertiesPanel();
			} else {
				editorState.selectedElement = null;
				updatePropertiesPanel();
				
				// Создание нового элемента
				 if (editorState.tool === 'rh') {
					editorState.tempElement = {
						type: 'rh',
						x1: worldPos.x,
						x2: worldPos.x,
						y: worldPos.y
					};
				}
				else if (editorState.tool === 'rv') {
					editorState.tempElement = {
						type: 'rv',
						x: worldPos.x,
						y1: worldPos.y,
						y2: worldPos.y
					};
				}
				else if (editorState.tool === 'room') {
					editorState.tempElement = {
						type: 'room',
						x1: worldPos.x,
						y1: worldPos.y,
						x2: worldPos.x,
						y2: worldPos.y
					};
				}
			}
		}
		
		function handleMouseMove(e) {
			const rect = canvas.getBoundingClientRect();
			const x = e.clientX - rect.left;
			const y = e.clientY - rect.top;
			const worldPos = screenToWorld(x, y);
			
			// Обновление отображения координат
			coordDisplay.textContent = `Координаты: (${worldPos.x.toFixed(1)}, ${worldPos.y.toFixed(1)})`;
			
			if (editorState.isDragging) {
				if (editorState.tool === 'pan' || (!editorState.selectedElement && editorState.tool === 'select')) {
					// Перемещение камеры
					const dx = (x - editorState.dragStartX) / editorState.scale;
					const dy = (editorState.dragStartY- y) / editorState.scale;
					
					editorState.offsetX = editorState.dragStartOffsetX - dx;
					editorState.offsetY = editorState.dragStartOffsetY + dy;
				}
				else if (editorState.selectedElement) {
					// Перемещение или изменение размера элемента
					const dx = (x - editorState.dragStartX) / editorState.scale;
					const dy = (editorState.dragStartY- y) / editorState.scale;
					const element = editorState.selectedElement;
					
					if (editorState.resizeHandle) {
						// Изменение размера
						if (element.type === 'rh') {
							if (editorState.resizeHandle === 'start') {
								element.data.x1 += dx;
							} else {
								element.data.x2 += dx;
							}
						}
						else if (element.type === 'rv') {
							if (editorState.resizeHandle === 'start') {
								element.data.y1 -= dy;
							} else {
								element.data.y2 -= dy;
							}
						}
						else if (element.type === 'room') {
							switch (editorState.resizeHandle) {
								case 'nw':
									element.data.x1 += dx;
									element.data.y1 -= dy;
									break;
								case 'ne':
									element.data.x2 += dx;
									element.data.y1 -= dy;
									break;
								case 'sw':
									element.data.x1 += dx;
									element.data.y2 -= dy;
									break;
								case 'se':
									element.data.x2 += dx;
									element.data.y2 -= dy;
									break;
							}
						}
					} else {
						// Перемещение элемента
						if (element.type === 'dollar') {
							element.data.x += dx;
							element.data.y -= dy;
						}
						else if (element.type === 'rh') {
							element.data.x1 += dx;
							element.data.x2 += dx;
							element.data.y -= dy;
						}
						else if (element.type === 'rv') {
							element.data.y1 -= dy;
							element.data.y2 -= dy;
							element.data.x += dx;
						}
						else if (element.type === 'room') {
							element.data.x1 += dx;
							element.data.x2 += dx;
							element.data.y1 -= dy;
							element.data.y2 -= dy;
						}
					}
					
					editorState.dragStartX = x;
					editorState.dragStartY = y;
					updatePropertiesPanel();
				}
				else if (editorState.tempElement) {
					// Продолжение создания нового элемента
					if (editorState.tempElement.type === 'rh') {
						if (worldPos.x>(editorState.tempElement.x2+editorState.tempElement.x1)/2)
							editorState.tempElement.x2 = worldPos.x;
						else
							editorState.tempElement.x1 = worldPos.x;
					}
					else if (editorState.tempElement.type === 'rv') {
						if (worldPos.y>(editorState.tempElement.y2+editorState.tempElement.y1)/2)
							editorState.tempElement.y2 = worldPos.y;
						else
							editorState.tempElement.y1 = worldPos.y;
					}
					else if (editorState.tempElement.type === 'room') {
						editorState.tempElement.x2 = worldPos.x;
						editorState.tempElement.y2 = worldPos.y;
					}
					updatePropertiesPanel();
				}
			}
		}
		
		function handleMouseUp(e) {
			if (editorState.selectedElement) {
				roundCoordinates(mapData);
			}
			if (editorState.tempElement) {
				// Завершение создания нового элемента
				if (editorState.tempElement.type === 'rh') {
					mapData.RHs.push({
						x1: editorState.tempElement.x1,
						x2: editorState.tempElement.x2,
						y: editorState.tempElement.y
					});
					editorState.selectedElement = { 
						type: 'rh', 
						index: mapData.RHs.length - 1, 
						data: mapData.RHs[mapData.RHs.length - 1] 
					};
				}
				else if (editorState.tempElement.type === 'rv') {
					mapData.RVs.push({
						x: editorState.tempElement.x,
						y1: editorState.tempElement.y1,
						y2: editorState.tempElement.y2
					});
					editorState.selectedElement = { 
						type: 'rv', 
						index: mapData.RVs.length - 1, 
						data: mapData.RVs[mapData.RVs.length - 1] 
					};
				}
				else if (editorState.tempElement.type === 'room') {
					mapData.ROOMs.push({
						x1: editorState.tempElement.x1,
						y1: editorState.tempElement.y1,
						x2: editorState.tempElement.x2,
						y2: editorState.tempElement.y2
					});
					editorState.selectedElement = { 
						type: 'room', 
						index: mapData.ROOMs.length - 1, 
						data: mapData.ROOMs[mapData.ROOMs.length - 1] 
					};
				}
				roundCoordinates(mapData);
				
				editorState.tempElement = null;
				updatePropertiesPanel();
			}
			
			function roundCoordinates(obj) {
				// Округление dollars
				if (obj.Ds) {
					obj.Ds.forEach(d => {
						d.x = Math.round(d.x);
						d.y = Math.round(d.y);
					});
				}
				
				// Округление horizontal roads и обеспечение x1 < x2
				if (obj.RHs) {
					obj.RHs.forEach(road => {
						road.x1 = Math.round(road.x1);
						road.x2 = Math.round(road.x2);
						road.y = Math.round(road.y);
						
						// Гарантируем что x1 < x2
						if (road.x1 > road.x2) {
							[road.x1, road.x2] = [road.x2, road.x1];
						}
					});
				}
				
				// Округление vertical roads и обеспечение y1 < y2
				if (obj.RVs) {
					obj.RVs.forEach(road => {
						road.x = Math.round(road.x);
						road.y1 = Math.round(road.y1);
						road.y2 = Math.round(road.y2);
						
						// Гарантируем что y1 < y2
						if (road.y1 > road.y2) {
							[road.y1, road.y2] = [road.y2, road.y1];
						}
					});
				}
				
				// Округление rooms и обеспечение x1 < x2 и y1 < y2
				if (obj.ROOMs) {
					obj.ROOMs.forEach(room => {
						room.x1 = Math.round(room.x1);
						room.y1 = Math.round(room.y1);
						room.x2 = Math.round(room.x2);
						room.y2 = Math.round(room.y2);
						
						// Гарантируем что x1 < x2
						if (room.x1 > room.x2) {
							[room.x1, room.x2] = [room.x2, room.x1];
						}
						
						// Гарантируем что y1 < y2
						if (room.y1 > room.y2) {
							[room.y1, room.y2] = [room.y2, room.y1];
						}
					});
				}
				
				editorUpdateValue();
			}
			
			updatePropertiesPanel();
			editorState.isDragging = false;
			editorState.resizeHandle = null;
		}
		
		function GetExcelColumnName(number)
		{
			var colName = '',
				dividend = Math.floor(Math.abs(number)),
				rest;
			while (dividend > 0) {
				rest = (dividend - 1) % 26;
				colName = String.fromCharCode(65 + rest) + colName;
				dividend = parseInt((dividend - rest)/26);
			}
			return colName;
		}
		
		function handleMouseWheel(e) {
			e.preventDefault();
			const zoomIntensity = 0.1;
			const wheel = -e.deltaY*0.01//e.deltaY < 0 ? 1 : -1;
			const zoom = Math.exp(wheel * zoomIntensity);
			
			const rect = canvas.getBoundingClientRect();
			const mouseX = e.clientX - rect.left;
			const mouseY = e.clientY - rect.top;
			
			const worldPosBefore = screenToWorld(mouseX, mouseY);
			
			editorState.scale *= zoom;
			editorState.scale = Math.max(editorState.minScale, Math.min(editorState.maxScale, editorState.scale));
			
			const worldPosAfter = screenToWorld(mouseX, mouseY);
			
			editorState.offsetX += worldPosBefore.x - worldPosAfter.x;
			editorState.offsetY += worldPosBefore.y - worldPosAfter.y;
			
			scaleDisplay.textContent = `Масштаб: ${Math.round(editorState.scale * 100)}%`;
		}
		
		// Обработка нажатий клавиш
		function handleKeyDown(e) {
			if (e.key === 'Delete' && editorState.selectedElement) {
				deleteElement(editorState.selectedElement);
				editorState.selectedElement = null;
				updatePropertiesPanel();
				editorUpdateValue();
			}
		}
		
		// Удаление элемента
		function deleteElement(element) {
			if (element.type === 'dollar') {
				mapData.Ds.splice(element.index, 1);
			}
			else if (element.type === 'rh') {
				mapData.RHs.splice(element.index, 1);
			}
			else if (element.type === 'rv') {
				mapData.RVs.splice(element.index, 1);
			}
			else if (element.type === 'room') {
				mapData.ROOMs.splice(element.index, 1);
			}
		}
		
		// Масштабирование
		function zoom(factor) {
			editorState.scale *= factor;
			editorState.scale = Math.max(editorState.minScale, Math.min(editorState.maxScale, editorState.scale));
			scaleDisplay.textContent = `Масштаб: ${Math.round(editorState.scale * 100)}%`;
		}
		
		// Сброс вида
		function resetView() {
			editorState.scale = 30.0;
			editorState.offsetX = 0;
			editorState.offsetY = 0;
			scaleDisplay.textContent = `Масштаб: ${Math.round(editorState.scale * 100)}%`;
		}
		
		// Обновление свойств элемента из UI
		function updateElementProperties() {
			if (!editorState.selectedElement) return;
			
			const element = editorState.selectedElement;
			
			if (element.type === 'dollar') {
				element.data.x = parseInt(document.getElementById('dollar-x').value)||0;
				element.data.y = parseInt(document.getElementById('dollar-y').value)||0;
				element.data.probability = (parseInt(document.getElementById('dollar-probability').value)||0)/100;
				element.data.init_probability = (parseInt(document.getElementById('dollar-init_probability').value)||100)/100;
			}
			else if (element.type === 'rh') {
				element.data.x1 = parseInt(document.getElementById('rh-x1').value)||0;
				element.data.x2 = parseInt(document.getElementById('rh-x2').value)||0;
				element.data.y = parseInt(document.getElementById('rh-y').value)||0;
				element.data.dor = document.getElementById('rh-dor').value||"";
			}
			else if (element.type === 'rv') {
				element.data.x = parseInt(document.getElementById('rv-x').value)||0;
				element.data.y1 = parseInt(document.getElementById('rv-y1').value)||0;
				element.data.y2 = parseInt(document.getElementById('rv-y2').value)||0;
				element.data.dor = document.getElementById('rv-dor').value||"";
			}
			else if (element.type === 'room') {
				element.data.x1 = parseInt(document.getElementById('room-x1').value)||0;
				element.data.y1 = parseInt(document.getElementById('room-y1').value)||0;
				element.data.x2 = parseInt(document.getElementById('room-x2').value)||0;
				element.data.y2 = parseInt(document.getElementById('room-y2').value)||0;
			}
			
			editorUpdateValue();
		}
		
		// Экспорт карты
		function exportMap() {
			const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(mapData, null, 2));
			const downloadAnchorNode = document.createElement('a');
			downloadAnchorNode.setAttribute("href", dataStr);
			downloadAnchorNode.setAttribute("download", "map_config.json");
			document.body.appendChild(downloadAnchorNode);
			downloadAnchorNode.click();
			downloadAnchorNode.remove();
		}
		
		// Импорт карты
		function importMap() {
			const input = document.createElement('input');
			input.type = 'file';
			input.accept = '.json';
			
			input.onchange = e => {
				const file = e.target.files[0];
				const reader = new FileReader();
				
				reader.onload = event => {
					try {
						const data = JSON.parse(event.target.result);
						Object.assign(mapData, data);
						editorState.selectedElement = null;
						updatePropertiesPanel();
					} catch (error) {
						alert('Ошибка при загрузке файла: неверный формат');
					}
				};
				
				reader.readAsText(file);
			};
			
			input.click();
		}
		
		// Очистка карты
		function clearMap() {
			if (confirm('Вы уверены, что хотите очистить всю карту?')) {
				mapData.Ds = [];
				mapData.RHs = [];
				mapData.RVs = [];
				mapData.ROOMs = [];
				editorState.selectedElement = null;
				updatePropertiesPanel();
			}
		}
		
		// Запуск редактора при загрузке страницы
		window.addEventListener('load', initEditor);
		
		
		
		
		
		
		function findMapProblems(mapData) {
			const { RHs, RVs, ROOMs, Ds } = mapData;
			const problems = [];

			// Проверка соединения дорог с комнатами
			function isPointInRoom(x, y, room) {
				return x >= room.x1 && x <= room.x2 && y >= room.y1 && y <= room.y2;
			}

			function isPointInAnyRoom(x, y) {
				return ROOMs.some(room => isPointInRoom(x, y, room));
			}

			Ds.forEach((D1,i) => {
				if (!isPointInAnyRoom(D1.x, D1.y))
					problems.push(D1);
				else
					Ds.forEach((D2,j) => {
						if (i!=j&&D1.x == D2.x && D1.y == D2.y) problems.push(D1);
					});
			});

			RHs.forEach(rh => {
				if (!isPointInAnyRoom(rh.x1-1, rh.y)) problems.push({ x: rh.x1-1, y: rh.y });
				if (!isPointInAnyRoom(rh.x2+1, rh.y)) problems.push({ x: rh.x2+1, y: rh.y });
			});

			RVs.forEach(rv => {
				if (!isPointInAnyRoom(rv.x, rv.y1-1)) problems.push({ x: rv.x, y: rv.y1-1 });
				if (!isPointInAnyRoom(rv.x, rv.y2+1)) problems.push({ x: rv.x, y: rv.y2+1 });
			});

			// Проверка пересечений комнат с расширенными областями
			function getExpandedRoom(room, notExpand) {
				if (notExpand) return room;
				return {
					x1: room.x1 - 2,
					x2: room.x2 + 2,
					y1: room.y1 - 3,
					y2: room.y2 + 3
				};
			}

			function getExpandedRV(road, notExpand) {
				if (notExpand){
					return {
						x1: road.x,
						x2: road.x,
						y1: road.y1,
						y2: road.y2
					};
				}
				return {
					x1: road.x-2,
					x2: road.x+2,
					y1: road.y1,
					y2: road.y2
				};
			}

			function getExpandedRH(road, notExpand) {
				if (notExpand){
					return {
						x1: road.x1,
						x2: road.x2,
						y1: road.y,
						y2: road.y
					};
				}
				return {
					x1: road.x1,
					x2: road.x2,
					y1: road.y - 3,
					y2: road.y + 3
				};
			}

			function getRectanglesOverlap(rect1, rect2) {
				const xOverlap = Math.max(0, Math.min(rect1.x2, rect2.x2) - Math.max(rect1.x1, rect2.x1) + 1);
				const yOverlap = Math.max(0, Math.min(rect1.y2, rect2.y2) - Math.max(rect1.y1, rect2.y1) + 1);
				
				if (xOverlap > 0 && yOverlap > 0) {
					const overlapX1 = Math.max(rect1.x1, rect2.x1);
					const overlapX2 = Math.min(rect1.x2, rect2.x2);
					const overlapY1 = Math.max(rect1.y1, rect2.y1);
					const overlapY2 = Math.min(rect1.y2, rect2.y2);
					
					// Возвращаем все точки пересечения
					const overlapPoints = [];
					for (let x = overlapX1; x <= overlapX2; x++) {
						for (let y = overlapY1; y <= overlapY2; y++) {
							overlapPoints.push({ x, y });
						}
					}
					return overlapPoints;
				}
				return [];
			}

			// Проверка пересечений комнат с расширенными областями
			for (let i = 0; i < ROOMs.length; i++) {
				const expandedRoom1 = getExpandedRoom(ROOMs[i]);
				for (let j = 0; j < ROOMs.length; j++) if (j!=i){
					const expandedRoom2 = getExpandedRoom(ROOMs[j], true);
					const overlapPoints = getRectanglesOverlap(expandedRoom1, expandedRoom2);
					problems.push(...overlapPoints);
				}
			}

			for (let i = 0; i < RHs.length; i++) {
				const expandedRH1 = getExpandedRH(RHs[i]);
				for (let j = 0; j < ROOMs.length; j++) if (j!=i){
					const expandedRoom2 = getExpandedRoom(ROOMs[j], true);
					const overlapPoints = getRectanglesOverlap(expandedRH1, expandedRoom2);
					problems.push(...overlapPoints);
				}
			}

			for (let i = 0; i < RVs.length; i++) {
				const expandedRV1 = getExpandedRV(RVs[i]);
				for (let j = 0; j < ROOMs.length; j++) if (j!=i){
					const expandedRoom2 = getExpandedRoom(ROOMs[j], true);
					const overlapPoints = getRectanglesOverlap(expandedRV1, expandedRoom2);
					problems.push(...overlapPoints);
				}
			}

			for (let i = 0; i < RHs.length; i++) {
				const expandedRH1 = getExpandedRH(RHs[i]);
				for (let j = 0; j < RHs.length; j++) if (j!=i){
					const expandedRH2 = getExpandedRH(RHs[j], true);
					const overlapPoints = getRectanglesOverlap(expandedRH1, expandedRH2);
					problems.push(...overlapPoints);
				}
			}

			for (let i = 0; i < RVs.length; i++) {
				const expandedRV1 = getExpandedRV(RVs[i]);
				for (let j = 0; j < RVs.length; j++) if (j!=i){
					const expandedRV2 = getExpandedRV(RVs[j], true);
					const overlapPoints = getRectanglesOverlap(expandedRV1, expandedRV2);
					problems.push(...overlapPoints);
				}
			}

			for (let i = 0; i < RHs.length; i++) {
				const expandedRH = getExpandedRH(RHs[i]);
				for (let j = 0; j < RVs.length; j++) {
					const expandedRV = getExpandedRV(RVs[j], true);
					const overlapPoints = getRectanglesOverlap(expandedRH, expandedRV);
					problems.push(...overlapPoints);
				}
			}

			for (let i = 0; i < RHs.length; i++) {
				const expandedRH = getExpandedRH(RHs[i], true);
				for (let j = 0; j < RVs.length; j++) {
					const expandedRV = getExpandedRV(RVs[j]);
					const overlapPoints = getRectanglesOverlap(expandedRH, expandedRV);
					problems.push(...overlapPoints);
				}
			}

			return problems.filter((point, index, array) => 
				array.findIndex(p => p.x === point.x && p.y === point.y) === index
			);
		}
		
		
		
		
		
		const editorPrefix = 'projMap';
		
		let last_editorUpdateValue = '';
		let timer_editorUpdateValue = 0;
		
		function editorUpdateValue() {
			let s = JSON.stringify(mapData);
			editorPostMessage('PreSetValue');
			
			if (s!=last_editorUpdateValue) {
				last_editorUpdateValue = s;
				if (timer_editorUpdateValue) clearTimeout(timer_editorUpdateValue);
				timer_editorUpdateValue = setTimeout(()=>{
					editorState.problems = findMapProblems(mapData);
					editorPostMessage('SetValue', mapData);
				}, 500);
			}
		}
		function editorPostMessage (type, value) {
			window.parent.postMessage({ type: editorPrefix+type, value: JSON.stringify(value) }, '*');
		}
		
		function updateIframeHeight() {
			const height = document.body.scrollHeight;
			
			editorPostMessage('SetHeight', 0);
		}
		
		
		window.addEventListener('load', ()=>{
			if (window.self !== window.top) {
			
				window.addEventListener('message', function(event) {
					if (event.data.type && event.data.type === editorPrefix+'SetData') {
						Object.assign(mapData, JSON.parse(event.data.value));
						select_data = [{ text:"Без двери", value: ""}, { text:"Открыта", value: "open" }];
						JSON.parse(event.data.additional.tasks).map(x=>{
							select_data.push({text: x, value:"task:"+x});
						});
						editorState.selectedElement = null;
						updatePropertiesPanel();
					}
				});
				
				updateIframeHeight();
				
				window.addEventListener('resize', updateIframeHeight);
				
				editorPostMessage('Init');
			}
		});
	</script>
</html>
</body>